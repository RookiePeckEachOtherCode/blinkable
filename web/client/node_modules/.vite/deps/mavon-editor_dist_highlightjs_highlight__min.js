import {
  __commonJS
} from "./chunk-ROME4SDB.js";

// ../../node_modules/mavon-editor/dist/highlightjs/highlight.min.js
var require_highlight_min = __commonJS({
  "../../node_modules/mavon-editor/dist/highlightjs/highlight.min.js"(exports, module) {
    var hljs = function() {
      "use strict";
      var e = { exports: {} };
      function n(e2) {
        return e2 instanceof Map ? e2.clear = e2.delete = e2.set = () => {
          throw Error("map is read-only");
        } : e2 instanceof Set && (e2.add = e2.clear = e2.delete = () => {
          throw Error("set is read-only");
        }), Object.freeze(e2), Object.getOwnPropertyNames(e2).forEach((t2) => {
          var a2 = e2[t2];
          "object" != typeof a2 || Object.isFrozen(a2) || n(a2);
        }), e2;
      }
      e.exports = n, e.exports.default = n;
      var t = e.exports;
      class a {
        constructor(e2) {
          void 0 === e2.data && (e2.data = {}), this.data = e2.data, this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      }
      function i(e2) {
        return e2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      function r(e2, ...n2) {
        const t2 = /* @__PURE__ */ Object.create(null);
        for (const n3 in e2)
          t2[n3] = e2[n3];
        return n2.forEach((e3) => {
          for (const n3 in e3)
            t2[n3] = e3[n3];
        }), t2;
      }
      const s = (e2) => !!e2.kind;
      class o {
        constructor(e2, n2) {
          this.buffer = "", this.classPrefix = n2.classPrefix, e2.walk(this);
        }
        addText(e2) {
          this.buffer += i(e2);
        }
        openNode(e2) {
          if (!s(e2))
            return;
          let n2 = e2.kind;
          n2 = e2.sublanguage ? "language-" + n2 : ((e3, { prefix: n3 }) => {
            if (e3.includes(".")) {
              const t2 = e3.split(".");
              return [`${n3}${t2.shift()}`, ...t2.map((e4, n4) => `${e4}${"_".repeat(n4 + 1)}`)].join(" ");
            }
            return `${n3}${e3}`;
          })(n2, { prefix: this.classPrefix }), this.span(n2);
        }
        closeNode(e2) {
          s(e2) && (this.buffer += "</span>");
        }
        value() {
          return this.buffer;
        }
        span(e2) {
          this.buffer += `<span class="${e2}">`;
        }
      }
      class l {
        constructor() {
          this.rootNode = {
            children: []
          }, this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        add(e2) {
          this.top.children.push(e2);
        }
        openNode(e2) {
          const n2 = { kind: e2, children: [] };
          this.add(n2), this.stack.push(n2);
        }
        closeNode() {
          if (this.stack.length > 1)
            return this.stack.pop();
        }
        closeAllNodes() {
          for (; this.closeNode(); )
            ;
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        walk(e2) {
          return this.constructor._walk(e2, this.rootNode);
        }
        static _walk(e2, n2) {
          return "string" == typeof n2 ? e2.addText(n2) : n2.children && (e2.openNode(n2), n2.children.forEach((n3) => this._walk(e2, n3)), e2.closeNode(n2)), e2;
        }
        static _collapse(e2) {
          "string" != typeof e2 && e2.children && (e2.children.every((e3) => "string" == typeof e3) ? e2.children = [e2.children.join("")] : e2.children.forEach((e3) => {
            l._collapse(e3);
          }));
        }
      }
      class c extends l {
        constructor(e2) {
          super(), this.options = e2;
        }
        addKeyword(e2, n2) {
          "" !== e2 && (this.openNode(n2), this.addText(e2), this.closeNode());
        }
        addText(e2) {
          "" !== e2 && this.add(e2);
        }
        addSublanguage(e2, n2) {
          const t2 = e2.root;
          t2.kind = n2, t2.sublanguage = true, this.add(t2);
        }
        toHTML() {
          return new o(this, this.options).value();
        }
        finalize() {
          return true;
        }
      }
      function d(e2) {
        return e2 ? "string" == typeof e2 ? e2 : e2.source : null;
      }
      function g(e2) {
        return m("(?=", e2, ")");
      }
      function u(e2) {
        return m("(?:", e2, ")*");
      }
      function b(e2) {
        return m("(?:", e2, ")?");
      }
      function m(...e2) {
        return e2.map((e3) => d(e3)).join("");
      }
      function p(...e2) {
        const n2 = ((e3) => {
          const n3 = e3[e3.length - 1];
          return "object" == typeof n3 && n3.constructor === Object ? (e3.splice(e3.length - 1, 1), n3) : {};
        })(e2);
        return "(" + (n2.capture ? "" : "?:") + e2.map((e3) => d(e3)).join("|") + ")";
      }
      function _(e2) {
        return RegExp(e2.toString() + "|").exec("").length - 1;
      }
      const h = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function f(e2, { joinWith: n2 }) {
        let t2 = 0;
        return e2.map((e3) => {
          t2 += 1;
          const n3 = t2;
          let a2 = d(e3), i2 = "";
          for (; a2.length > 0; ) {
            const e4 = h.exec(a2);
            if (!e4) {
              i2 += a2;
              break;
            }
            i2 += a2.substring(0, e4.index), a2 = a2.substring(e4.index + e4[0].length), "\\" === e4[0][0] && e4[1] ? i2 += "\\" + (Number(e4[1]) + n3) : (i2 += e4[0], "(" === e4[0] && t2++);
          }
          return i2;
        }).map((e3) => `(${e3})`).join(n2);
      }
      const E = "[a-zA-Z]\\w*", y = "[a-zA-Z_]\\w*", N = "\\b\\d+(\\.\\d+)?", w = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", v = "\\b(0b[01]+)", O = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      }, x = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [O]
      }, M = {
        scope: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [O]
      }, k = (e2, n2, t2 = {}) => {
        const a2 = r({
          scope: "comment",
          begin: e2,
          end: n2,
          contains: []
        }, t2);
        a2.contains.push({
          scope: "doctag",
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: true,
          relevance: 0
        });
        const i2 = p("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
        return a2.contains.push({ begin: m(/[ ]+/, "(", i2, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), a2;
      }, S = k("//", "$"), A = k("/\\*", "\\*/"), C = k("#", "$");
      var T = Object.freeze({
        __proto__: null,
        MATCH_NOTHING_RE: /\b\B/,
        IDENT_RE: E,
        UNDERSCORE_IDENT_RE: y,
        NUMBER_RE: N,
        C_NUMBER_RE: w,
        BINARY_NUMBER_RE: v,
        RE_STARTERS_RE: "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
        SHEBANG: (e2 = {}) => {
          const n2 = /^#![ ]*\//;
          return e2.binary && (e2.begin = m(n2, /.*\b/, e2.binary, /\b.*/)), r({
            scope: "meta",
            begin: n2,
            end: /$/,
            relevance: 0,
            "on:begin": (e3, n3) => {
              0 !== e3.index && n3.ignoreMatch();
            }
          }, e2);
        },
        BACKSLASH_ESCAPE: O,
        APOS_STRING_MODE: x,
        QUOTE_STRING_MODE: M,
        PHRASAL_WORDS_MODE: {
          begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
        },
        COMMENT: k,
        C_LINE_COMMENT_MODE: S,
        C_BLOCK_COMMENT_MODE: A,
        HASH_COMMENT_MODE: C,
        NUMBER_MODE: { scope: "number", begin: N, relevance: 0 },
        C_NUMBER_MODE: {
          scope: "number",
          begin: w,
          relevance: 0
        },
        BINARY_NUMBER_MODE: { scope: "number", begin: v, relevance: 0 },
        REGEXP_MODE: { begin: /(?=\/[^/\n]*\/)/, contains: [{
          scope: "regexp",
          begin: /\//,
          end: /\/[gimuy]*/,
          illegal: /\n/,
          contains: [O, {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [O]
          }]
        }] },
        TITLE_MODE: { scope: "title", begin: E, relevance: 0 },
        UNDERSCORE_TITLE_MODE: { scope: "title", begin: y, relevance: 0 },
        METHOD_GUARD: {
          begin: "\\.\\s*[a-zA-Z_]\\w*",
          relevance: 0
        },
        END_SAME_AS_BEGIN: (e2) => Object.assign(e2, {
          "on:begin": (e3, n2) => {
            n2.data._beginMatch = e3[1];
          },
          "on:end": (e3, n2) => {
            n2.data._beginMatch !== e3[1] && n2.ignoreMatch();
          }
        })
      });
      function R(e2, n2) {
        "." === e2.input[e2.index - 1] && n2.ignoreMatch();
      }
      function D(e2, n2) {
        void 0 !== e2.className && (e2.scope = e2.className, delete e2.className);
      }
      function I(e2, n2) {
        n2 && e2.beginKeywords && (e2.begin = "\\b(" + e2.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", e2.__beforeBegin = R, e2.keywords = e2.keywords || e2.beginKeywords, delete e2.beginKeywords, void 0 === e2.relevance && (e2.relevance = 0));
      }
      function L(e2, n2) {
        Array.isArray(e2.illegal) && (e2.illegal = p(...e2.illegal));
      }
      function B(e2, n2) {
        if (e2.match) {
          if (e2.begin || e2.end)
            throw Error("begin & end are not supported with match");
          e2.begin = e2.match, delete e2.match;
        }
      }
      function $(e2, n2) {
        void 0 === e2.relevance && (e2.relevance = 1);
      }
      const F = (e2, n2) => {
        if (!e2.beforeMatch)
          return;
        if (e2.starts)
          throw Error("beforeMatch cannot be used with starts");
        const t2 = Object.assign({}, e2);
        Object.keys(e2).forEach((n3) => {
          delete e2[n3];
        }), e2.keywords = t2.keywords, e2.begin = m(t2.beforeMatch, g(t2.begin)), e2.starts = {
          relevance: 0,
          contains: [Object.assign(t2, { endsParent: true })]
        }, e2.relevance = 0, delete t2.beforeMatch;
      }, z = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"];
      function U(e2, n2, t2 = "keyword") {
        const a2 = /* @__PURE__ */ Object.create(null);
        return "string" == typeof e2 ? i2(t2, e2.split(" ")) : Array.isArray(e2) ? i2(t2, e2) : Object.keys(e2).forEach((t3) => {
          Object.assign(a2, U(e2[t3], n2, t3));
        }), a2;
        function i2(e3, t3) {
          n2 && (t3 = t3.map((e4) => e4.toLowerCase())), t3.forEach((n3) => {
            const t4 = n3.split("|");
            a2[t4[0]] = [e3, j(t4[0], t4[1])];
          });
        }
      }
      function j(e2, n2) {
        return n2 ? Number(n2) : ((e3) => z.includes(e3.toLowerCase()))(e2) ? 0 : 1;
      }
      const P = {}, K = (e2) => {
        console.error(e2);
      }, q = (e2, ...n2) => {
        console.log("WARN: " + e2, ...n2);
      }, H = (e2, n2) => {
        P[`${e2}/${n2}`] || (console.log(`Deprecated as of ${e2}. ${n2}`), P[`${e2}/${n2}`] = true);
      }, Z = Error();
      function G(e2, n2, { key: t2 }) {
        let a2 = 0;
        const i2 = e2[t2], r2 = {}, s2 = {};
        for (let e3 = 1; e3 <= n2.length; e3++)
          s2[e3 + a2] = i2[e3], r2[e3 + a2] = true, a2 += _(n2[e3 - 1]);
        e2[t2] = s2, e2[t2]._emit = r2, e2[t2]._multi = true;
      }
      function W(e2) {
        ((e3) => {
          e3.scope && "object" == typeof e3.scope && null !== e3.scope && (e3.beginScope = e3.scope, delete e3.scope);
        })(e2), "string" == typeof e2.beginScope && (e2.beginScope = {
          _wrap: e2.beginScope
        }), "string" == typeof e2.endScope && (e2.endScope = {
          _wrap: e2.endScope
        }), ((e3) => {
          if (Array.isArray(e3.begin)) {
            if (e3.skip || e3.excludeBegin || e3.returnBegin)
              throw K("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Z;
            if ("object" != typeof e3.beginScope || null === e3.beginScope)
              throw K("beginScope must be object"), Z;
            G(e3, e3.begin, { key: "beginScope" }), e3.begin = f(e3.begin, { joinWith: "" });
          }
        })(e2), ((e3) => {
          if (Array.isArray(e3.end)) {
            if (e3.skip || e3.excludeEnd || e3.returnEnd)
              throw K("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Z;
            if ("object" != typeof e3.endScope || null === e3.endScope)
              throw K("endScope must be object"), Z;
            G(e3, e3.end, { key: "endScope" }), e3.end = f(e3.end, { joinWith: "" });
          }
        })(e2);
      }
      function Q(e2) {
        function n2(n3, t3) {
          return RegExp(d(n3), "m" + (e2.case_insensitive ? "i" : "") + (e2.unicodeRegex ? "u" : "") + (t3 ? "g" : ""));
        }
        class t2 {
          constructor() {
            this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
          }
          addRule(e3, n3) {
            n3.position = this.position++, this.matchIndexes[this.matchAt] = n3, this.regexes.push([n3, e3]), this.matchAt += _(e3) + 1;
          }
          compile() {
            0 === this.regexes.length && (this.exec = () => null);
            const e3 = this.regexes.map((e4) => e4[1]);
            this.matcherRe = n2(f(e3, {
              joinWith: "|"
            }), true), this.lastIndex = 0;
          }
          exec(e3) {
            this.matcherRe.lastIndex = this.lastIndex;
            const n3 = this.matcherRe.exec(e3);
            if (!n3)
              return null;
            const t3 = n3.findIndex((e4, n4) => n4 > 0 && void 0 !== e4), a3 = this.matchIndexes[t3];
            return n3.splice(0, t3), Object.assign(n3, a3);
          }
        }
        class a2 {
          constructor() {
            this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
          }
          getMatcher(e3) {
            if (this.multiRegexes[e3])
              return this.multiRegexes[e3];
            const n3 = new t2();
            return this.rules.slice(e3).forEach(([e4, t3]) => n3.addRule(e4, t3)), n3.compile(), this.multiRegexes[e3] = n3, n3;
          }
          resumingScanAtSamePosition() {
            return 0 !== this.regexIndex;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          addRule(e3, n3) {
            this.rules.push([e3, n3]), "begin" === n3.type && this.count++;
          }
          exec(e3) {
            const n3 = this.getMatcher(this.regexIndex);
            n3.lastIndex = this.lastIndex;
            let t3 = n3.exec(e3);
            if (this.resumingScanAtSamePosition())
              if (t3 && t3.index === this.lastIndex)
                ;
              else {
                const n4 = this.getMatcher(0);
                n4.lastIndex = this.lastIndex + 1, t3 = n4.exec(e3);
              }
            return t3 && (this.regexIndex += t3.position + 1, this.regexIndex === this.count && this.considerAll()), t3;
          }
        }
        if (e2.compilerExtensions || (e2.compilerExtensions = []), e2.contains && e2.contains.includes("self"))
          throw Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        return e2.classNameAliases = r(e2.classNameAliases || {}), function t3(i2, s2) {
          const o2 = i2;
          if (i2.isCompiled)
            return o2;
          [D, B, W, F].forEach((e3) => e3(i2, s2)), e2.compilerExtensions.forEach((e3) => e3(i2, s2)), i2.__beforeBegin = null, [I, L, $].forEach((e3) => e3(i2, s2)), i2.isCompiled = true;
          let l2 = null;
          return "object" == typeof i2.keywords && i2.keywords.$pattern && (i2.keywords = Object.assign({}, i2.keywords), l2 = i2.keywords.$pattern, delete i2.keywords.$pattern), l2 = l2 || /\w+/, i2.keywords && (i2.keywords = U(i2.keywords, e2.case_insensitive)), o2.keywordPatternRe = n2(l2, true), s2 && (i2.begin || (i2.begin = /\B|\b/), o2.beginRe = n2(o2.begin), i2.end || i2.endsWithParent || (i2.end = /\B|\b/), i2.end && (o2.endRe = n2(o2.end)), o2.terminatorEnd = d(o2.end) || "", i2.endsWithParent && s2.terminatorEnd && (o2.terminatorEnd += (i2.end ? "|" : "") + s2.terminatorEnd)), i2.illegal && (o2.illegalRe = n2(i2.illegal)), i2.contains || (i2.contains = []), i2.contains = [].concat(...i2.contains.map((e3) => ((e4) => (e4.variants && !e4.cachedVariants && (e4.cachedVariants = e4.variants.map((n3) => r(e4, {
            variants: null
          }, n3))), e4.cachedVariants ? e4.cachedVariants : X(e4) ? r(e4, {
            starts: e4.starts ? r(e4.starts) : null
          }) : Object.isFrozen(e4) ? r(e4) : e4))("self" === e3 ? i2 : e3))), i2.contains.forEach((e3) => {
            t3(e3, o2);
          }), i2.starts && t3(i2.starts, s2), o2.matcher = ((e3) => {
            const n3 = new a2();
            return e3.contains.forEach((e4) => n3.addRule(e4.begin, {
              rule: e4,
              type: "begin"
            })), e3.terminatorEnd && n3.addRule(e3.terminatorEnd, {
              type: "end"
            }), e3.illegal && n3.addRule(e3.illegal, { type: "illegal" }), n3;
          })(o2), o2;
        }(e2);
      }
      function X(e2) {
        return !!e2 && (e2.endsWithParent || X(e2.starts));
      }
      class V extends Error {
        constructor(e2, n2) {
          super(e2), this.name = "HTMLInjectionError", this.html = n2;
        }
      }
      const J = i, Y = r, ee = Symbol("nomatch");
      var ne = ((e2) => {
        const n2 = /* @__PURE__ */ Object.create(null), i2 = /* @__PURE__ */ Object.create(null), r2 = [];
        let s2 = true;
        const o2 = "Could not find the language '{}', did you forget to load/include a language module?", l2 = {
          disableAutodetect: true,
          name: "Plain text",
          contains: []
        };
        let d2 = {
          ignoreUnescapedHTML: false,
          throwUnescapedHTML: false,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          __emitter: c
        };
        function _2(e3) {
          return d2.noHighlightRe.test(e3);
        }
        function h2(e3, n3, t2) {
          let a2 = "", i3 = "";
          "object" == typeof n3 ? (a2 = e3, t2 = n3.ignoreIllegals, i3 = n3.language) : (H("10.7.0", "highlight(lang, code, ...args) has been deprecated."), H("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"), i3 = e3, a2 = n3), void 0 === t2 && (t2 = true);
          const r3 = { code: a2, language: i3 };
          M2("before:highlight", r3);
          const s3 = r3.result ? r3.result : f2(r3.language, r3.code, t2);
          return s3.code = r3.code, M2("after:highlight", s3), s3;
        }
        function f2(e3, t2, i3, r3) {
          const l3 = /* @__PURE__ */ Object.create(null);
          function c2() {
            if (!x3.keywords)
              return void k2.addText(S2);
            let e4 = 0;
            x3.keywordPatternRe.lastIndex = 0;
            let n3 = x3.keywordPatternRe.exec(S2), t3 = "";
            for (; n3; ) {
              t3 += S2.substring(e4, n3.index);
              const i4 = N3.case_insensitive ? n3[0].toLowerCase() : n3[0], r4 = (a2 = i4, x3.keywords[a2]);
              if (r4) {
                const [e5, a3] = r4;
                if (k2.addText(t3), t3 = "", l3[i4] = (l3[i4] || 0) + 1, l3[i4] <= 7 && (A2 += a3), e5.startsWith("_"))
                  t3 += n3[0];
                else {
                  const t4 = N3.classNameAliases[e5] || e5;
                  k2.addKeyword(n3[0], t4);
                }
              } else
                t3 += n3[0];
              e4 = x3.keywordPatternRe.lastIndex, n3 = x3.keywordPatternRe.exec(S2);
            }
            var a2;
            t3 += S2.substr(e4), k2.addText(t3);
          }
          function g2() {
            null != x3.subLanguage ? (() => {
              if ("" === S2)
                return;
              let e4 = null;
              if ("string" == typeof x3.subLanguage) {
                if (!n2[x3.subLanguage])
                  return void k2.addText(S2);
                e4 = f2(x3.subLanguage, S2, true, M3[x3.subLanguage]), M3[x3.subLanguage] = e4._top;
              } else
                e4 = E2(S2, x3.subLanguage.length ? x3.subLanguage : null);
              x3.relevance > 0 && (A2 += e4.relevance), k2.addSublanguage(e4._emitter, e4.language);
            })() : c2(), S2 = "";
          }
          function u2(e4, n3) {
            let t3 = 1;
            for (; void 0 !== n3[t3]; ) {
              if (!e4._emit[t3]) {
                t3++;
                continue;
              }
              const a2 = N3.classNameAliases[e4[t3]] || e4[t3], i4 = n3[t3];
              a2 ? k2.addKeyword(i4, a2) : (S2 = i4, c2(), S2 = ""), t3++;
            }
          }
          function b2(e4, n3) {
            return e4.scope && "string" == typeof e4.scope && k2.openNode(N3.classNameAliases[e4.scope] || e4.scope), e4.beginScope && (e4.beginScope._wrap ? (k2.addKeyword(S2, N3.classNameAliases[e4.beginScope._wrap] || e4.beginScope._wrap), S2 = "") : e4.beginScope._multi && (u2(e4.beginScope, n3), S2 = "")), x3 = Object.create(e4, { parent: {
              value: x3
            } }), x3;
          }
          function m2(e4, n3, t3) {
            let i4 = ((e5, n4) => {
              const t4 = e5 && e5.exec(n4);
              return t4 && 0 === t4.index;
            })(e4.endRe, t3);
            if (i4) {
              if (e4["on:end"]) {
                const t4 = new a(e4);
                e4["on:end"](n3, t4), t4.isMatchIgnored && (i4 = false);
              }
              if (i4) {
                for (; e4.endsParent && e4.parent; )
                  e4 = e4.parent;
                return e4;
              }
            }
            if (e4.endsWithParent)
              return m2(e4.parent, n3, t3);
          }
          function p2(e4) {
            return 0 === x3.matcher.regexIndex ? (S2 += e4[0], 1) : (R2 = true, 0);
          }
          function _3(e4) {
            const n3 = e4[0], a2 = t2.substr(e4.index), i4 = m2(x3, e4, a2);
            if (!i4)
              return ee;
            const r4 = x3;
            x3.endScope && x3.endScope._wrap ? (g2(), k2.addKeyword(n3, x3.endScope._wrap)) : x3.endScope && x3.endScope._multi ? (g2(), u2(x3.endScope, e4)) : r4.skip ? S2 += n3 : (r4.returnEnd || r4.excludeEnd || (S2 += n3), g2(), r4.excludeEnd && (S2 = n3));
            do {
              x3.scope && k2.closeNode(), x3.skip || x3.subLanguage || (A2 += x3.relevance), x3 = x3.parent;
            } while (x3 !== i4.parent);
            return i4.starts && b2(i4.starts, e4), r4.returnEnd ? 0 : n3.length;
          }
          let h3 = {};
          function y3(n3, r4) {
            const o3 = r4 && r4[0];
            if (S2 += n3, null == o3)
              return g2(), 0;
            if ("begin" === h3.type && "end" === r4.type && h3.index === r4.index && "" === o3) {
              if (S2 += t2.slice(r4.index, r4.index + 1), !s2) {
                const n4 = Error(`0 width match regex (${e3})`);
                throw n4.languageName = e3, n4.badRule = h3.rule, n4;
              }
              return 1;
            }
            if (h3 = r4, "begin" === r4.type)
              return ((e4) => {
                const n4 = e4[0], t3 = e4.rule, i4 = new a(t3), r5 = [t3.__beforeBegin, t3["on:begin"]];
                for (const t4 of r5)
                  if (t4 && (t4(e4, i4), i4.isMatchIgnored))
                    return p2(n4);
                return t3.skip ? S2 += n4 : (t3.excludeBegin && (S2 += n4), g2(), t3.returnBegin || t3.excludeBegin || (S2 = n4)), b2(t3, e4), t3.returnBegin ? 0 : n4.length;
              })(r4);
            if ("illegal" === r4.type && !i3) {
              const e4 = Error('Illegal lexeme "' + o3 + '" for mode "' + (x3.scope || "<unnamed>") + '"');
              throw e4.mode = x3, e4;
            }
            if ("end" === r4.type) {
              const e4 = _3(r4);
              if (e4 !== ee)
                return e4;
            }
            if ("illegal" === r4.type && "" === o3)
              return 1;
            if (T2 > 1e5 && T2 > 3 * r4.index)
              throw Error("potential infinite loop, way more iterations than matches");
            return S2 += o3, o3.length;
          }
          const N3 = v2(e3);
          if (!N3)
            throw K(o2.replace("{}", e3)), Error('Unknown language: "' + e3 + '"');
          const w3 = Q(N3);
          let O3 = "", x3 = r3 || w3;
          const M3 = {}, k2 = new d2.__emitter(d2);
          (() => {
            const e4 = [];
            for (let n3 = x3; n3 !== N3; n3 = n3.parent)
              n3.scope && e4.unshift(n3.scope);
            e4.forEach((e5) => k2.openNode(e5));
          })();
          let S2 = "", A2 = 0, C2 = 0, T2 = 0, R2 = false;
          try {
            for (x3.matcher.considerAll(); ; ) {
              T2++, R2 ? R2 = false : x3.matcher.considerAll(), x3.matcher.lastIndex = C2;
              const e4 = x3.matcher.exec(t2);
              if (!e4)
                break;
              const n3 = y3(t2.substring(C2, e4.index), e4);
              C2 = e4.index + n3;
            }
            return y3(t2.substr(C2)), k2.closeAllNodes(), k2.finalize(), O3 = k2.toHTML(), {
              language: e3,
              value: O3,
              relevance: A2,
              illegal: false,
              _emitter: k2,
              _top: x3
            };
          } catch (n3) {
            if (n3.message && n3.message.includes("Illegal"))
              return {
                language: e3,
                value: J(t2),
                illegal: true,
                relevance: 0,
                _illegalBy: {
                  message: n3.message,
                  index: C2,
                  context: t2.slice(C2 - 100, C2 + 100),
                  mode: n3.mode,
                  resultSoFar: O3
                },
                _emitter: k2
              };
            if (s2)
              return {
                language: e3,
                value: J(t2),
                illegal: false,
                relevance: 0,
                errorRaised: n3,
                _emitter: k2,
                _top: x3
              };
            throw n3;
          }
        }
        function E2(e3, t2) {
          t2 = t2 || d2.languages || Object.keys(n2);
          const a2 = ((e4) => {
            const n3 = { value: J(e4), illegal: false, relevance: 0, _top: l2, _emitter: new d2.__emitter(d2) };
            return n3._emitter.addText(e4), n3;
          })(e3), i3 = t2.filter(v2).filter(x2).map((n3) => f2(n3, e3, false));
          i3.unshift(a2);
          const r3 = i3.sort((e4, n3) => {
            if (e4.relevance !== n3.relevance)
              return n3.relevance - e4.relevance;
            if (e4.language && n3.language) {
              if (v2(e4.language).supersetOf === n3.language)
                return 1;
              if (v2(n3.language).supersetOf === e4.language)
                return -1;
            }
            return 0;
          }), [s3, o3] = r3, c2 = s3;
          return c2.secondBest = o3, c2;
        }
        function y2(e3) {
          let n3 = null;
          const t2 = ((e4) => {
            let n4 = e4.className + " ";
            n4 += e4.parentNode ? e4.parentNode.className : "";
            const t3 = d2.languageDetectRe.exec(n4);
            if (t3) {
              const n5 = v2(t3[1]);
              return n5 || (q(o2.replace("{}", t3[1])), q("Falling back to no-highlight mode for this block.", e4)), n5 ? t3[1] : "no-highlight";
            }
            return n4.split(/\s+/).find((e5) => _2(e5) || v2(e5));
          })(e3);
          if (_2(t2))
            return;
          if (M2("before:highlightElement", {
            el: e3,
            language: t2
          }), e3.children.length > 0 && (d2.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/issues/2886"), console.warn(e3)), d2.throwUnescapedHTML))
            throw new V("One of your code blocks includes unescaped HTML.", e3.innerHTML);
          n3 = e3;
          const a2 = n3.textContent, r3 = t2 ? h2(a2, { language: t2, ignoreIllegals: true }) : E2(a2);
          e3.innerHTML = r3.value, ((e4, n4, t3) => {
            const a3 = n4 && i2[n4] || t3;
            e4.classList.add("hljs"), e4.classList.add("language-" + a3);
          })(e3, t2, r3.language), e3.result = {
            language: r3.language,
            re: r3.relevance,
            relevance: r3.relevance
          }, r3.secondBest && (e3.secondBest = {
            language: r3.secondBest.language,
            relevance: r3.secondBest.relevance
          }), M2("after:highlightElement", { el: e3, result: r3, text: a2 });
        }
        let N2 = false;
        function w2() {
          "loading" !== document.readyState ? document.querySelectorAll(d2.cssSelector).forEach(y2) : N2 = true;
        }
        function v2(e3) {
          return e3 = (e3 || "").toLowerCase(), n2[e3] || n2[i2[e3]];
        }
        function O2(e3, { languageName: n3 }) {
          "string" == typeof e3 && (e3 = [e3]), e3.forEach((e4) => {
            i2[e4.toLowerCase()] = n3;
          });
        }
        function x2(e3) {
          const n3 = v2(e3);
          return n3 && !n3.disableAutodetect;
        }
        function M2(e3, n3) {
          const t2 = e3;
          r2.forEach((e4) => {
            e4[t2] && e4[t2](n3);
          });
        }
        "undefined" != typeof window && window.addEventListener && window.addEventListener("DOMContentLoaded", () => {
          N2 && w2();
        }, false), Object.assign(e2, {
          highlight: h2,
          highlightAuto: E2,
          highlightAll: w2,
          highlightElement: y2,
          highlightBlock: (e3) => (H("10.7.0", "highlightBlock will be removed entirely in v12.0"), H("10.7.0", "Please use highlightElement now."), y2(e3)),
          configure: (e3) => {
            d2 = Y(d2, e3);
          },
          initHighlighting: () => {
            w2(), H("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
          },
          initHighlightingOnLoad: () => {
            w2(), H("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
          },
          registerLanguage: (t2, a2) => {
            let i3 = null;
            try {
              i3 = a2(e2);
            } catch (e3) {
              if (K("Language definition for '{}' could not be registered.".replace("{}", t2)), !s2)
                throw e3;
              K(e3), i3 = l2;
            }
            i3.name || (i3.name = t2), n2[t2] = i3, i3.rawDefinition = a2.bind(null, e2), i3.aliases && O2(i3.aliases, {
              languageName: t2
            });
          },
          unregisterLanguage: (e3) => {
            delete n2[e3];
            for (const n3 of Object.keys(i2))
              i2[n3] === e3 && delete i2[n3];
          },
          listLanguages: () => Object.keys(n2),
          getLanguage: v2,
          registerAliases: O2,
          autoDetection: x2,
          inherit: Y,
          addPlugin: (e3) => {
            ((e4) => {
              e4["before:highlightBlock"] && !e4["before:highlightElement"] && (e4["before:highlightElement"] = (n3) => {
                e4["before:highlightBlock"](Object.assign({ block: n3.el }, n3));
              }), e4["after:highlightBlock"] && !e4["after:highlightElement"] && (e4["after:highlightElement"] = (n3) => {
                e4["after:highlightBlock"](Object.assign({ block: n3.el }, n3));
              });
            })(e3), r2.push(e3);
          }
        }), e2.debugMode = () => {
          s2 = false;
        }, e2.safeMode = () => {
          s2 = true;
        }, e2.versionString = "11.3.1", e2.regex = {
          concat: m,
          lookahead: g,
          either: p,
          optional: b,
          anyNumberOfTimes: u
        };
        for (const e3 in T)
          "object" == typeof T[e3] && t(T[e3]);
        return Object.assign(e2, T), e2;
      })({});
      const te = (e2) => ({
        IMPORTANT: {
          scope: "meta",
          begin: "!important"
        },
        BLOCK_COMMENT: e2.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: {
          scope: "number",
          begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
        },
        FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
        ATTRIBUTE_SELECTOR_MODE: {
          scope: "selector-attr",
          begin: /\[/,
          end: /\]/,
          illegal: "$",
          contains: [e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE]
        },
        CSS_NUMBER_MODE: {
          scope: "number",
          begin: e2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
          relevance: 0
        },
        CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z][A-Za-z0-9_-]*/ }
      }), ae = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "p", "q", "quote", "samp", "section", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"], ie = ["any-hover", "any-pointer", "aspect-ratio", "color", "color-gamut", "color-index", "device-aspect-ratio", "device-height", "device-width", "display-mode", "forced-colors", "grid", "height", "hover", "inverted-colors", "monochrome", "orientation", "overflow-block", "overflow-inline", "pointer", "prefers-color-scheme", "prefers-contrast", "prefers-reduced-motion", "prefers-reduced-transparency", "resolution", "scan", "scripting", "update", "width", "min-width", "max-width", "min-height", "max-height"], re = ["active", "any-link", "blank", "checked", "current", "default", "defined", "dir", "disabled", "drop", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "future", "focus", "focus-visible", "focus-within", "has", "host", "host-context", "hover", "indeterminate", "in-range", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "local-link", "not", "nth-child", "nth-col", "nth-last-child", "nth-last-col", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "past", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "target", "target-within", "user-invalid", "valid", "visited", "where"], se = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"], oe = ["align-content", "align-items", "align-self", "all", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "clip-path", "clip-rule", "color", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "content", "content-visibility", "counter-increment", "counter-reset", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "empty-cells", "filter", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "flow", "font", "font-display", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "gap", "glyph-orientation-vertical", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "ime-mode", "isolation", "justify-content", "left", "letter-spacing", "line-break", "line-height", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marks", "mask", "mask-border", "mask-border-mode", "mask-border-outset", "mask-border-repeat", "mask-border-slice", "mask-border-source", "mask-border-width", "mask-clip", "mask-composite", "mask-image", "mask-mode", "mask-origin", "mask-position", "mask-repeat", "mask-size", "mask-type", "max-height", "max-width", "min-height", "min-width", "mix-blend-mode", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "none", "normal", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page-break-after", "page-break-before", "page-break-inside", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pointer-events", "position", "quotes", "resize", "rest", "rest-after", "rest-before", "right", "row-gap", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-stop", "scroll-snap-type", "shape-image-threshold", "shape-margin", "shape-outside", "speak", "speak-as", "src", "tab-size", "table-layout", "text-align", "text-align-all", "text-align-last", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-indent", "text-justify", "text-orientation", "text-overflow", "text-rendering", "text-shadow", "text-transform", "text-underline-position", "top", "transform", "transform-box", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index"].reverse(), le = re.concat(se);
      var ce = "\\.([0-9](_*[0-9])*)", de = "[0-9a-fA-F](_*[0-9a-fA-F])*", ge = {
        className: "number",
        variants: [{
          begin: `(\\b([0-9](_*[0-9])*)((${ce})|\\.)?|(${ce}))[eE][+-]?([0-9](_*[0-9])*)[fFdD]?\\b`
        }, { begin: `\\b([0-9](_*[0-9])*)((${ce})[fFdD]?\\b|\\.([fFdD]\\b)?)` }, {
          begin: `(${ce})[fFdD]?\\b`
        }, { begin: "\\b([0-9](_*[0-9])*)[fFdD]\\b" }, {
          begin: `\\b0[xX]((${de})\\.?|(${de})?\\.(${de}))[pP][+-]?([0-9](_*[0-9])*)[fFdD]?\\b`
        }, { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" }, { begin: `\\b0[xX](${de})[lL]?\\b` }, {
          begin: "\\b0(_*[0-7])*[lL]?\\b"
        }, { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }],
        relevance: 0
      };
      function ue(e2, n2, t2) {
        return -1 === t2 ? "" : e2.replace(n2, (a2) => ue(e2, n2, t2 - 1));
      }
      const be = "[A-Za-z$_][0-9A-Za-z$_]*", me = ["as", "in", "of", "if", "for", "while", "finally", "var", "new", "function", "do", "return", "void", "else", "break", "catch", "instanceof", "with", "throw", "case", "default", "try", "switch", "continue", "typeof", "delete", "let", "yield", "const", "class", "debugger", "async", "await", "static", "import", "from", "export", "extends"], pe = ["true", "false", "null", "undefined", "NaN", "Infinity"], _e = ["Object", "Function", "Boolean", "Symbol", "Math", "Date", "Number", "BigInt", "String", "RegExp", "Array", "Float32Array", "Float64Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Int32Array", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array", "Set", "Map", "WeakSet", "WeakMap", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "Reflect", "Proxy", "Intl", "WebAssembly"], he = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"], fe = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"], Ee = ["arguments", "this", "super", "console", "window", "document", "localStorage", "module", "global"], ye = [].concat(fe, _e, he);
      function Ne(e2) {
        const n2 = e2.regex, t2 = be, a2 = {
          begin: /<[A-Za-z0-9\\._:-]+/,
          end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
          isTrulyOpeningTag: (e3, n3) => {
            const t3 = e3[0].length + e3.index, a3 = e3.input[t3];
            if ("<" === a3 || "," === a3)
              return void n3.ignoreMatch();
            let i3;
            ">" === a3 && (((e4, { after: n4 }) => {
              const t4 = "</" + e4[0].slice(1);
              return -1 !== e4.input.indexOf(t4, n4);
            })(e3, {
              after: t3
            }) || n3.ignoreMatch()), (i3 = e3.input.substr(t3).match(/^\s+extends\s+/)) && 0 === i3.index && n3.ignoreMatch();
          }
        }, i2 = {
          $pattern: be,
          keyword: me,
          literal: pe,
          built_in: ye,
          "variable.language": Ee
        }, r2 = "\\.([0-9](_?[0-9])*)", s2 = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", o2 = {
          className: "number",
          variants: [{
            begin: `(\\b(${s2})((${r2})|\\.)?|(${r2}))[eE][+-]?([0-9](_?[0-9])*)\\b`
          }, {
            begin: `\\b(${s2})\\b((${r2})\\b|\\.)?|(${r2})\\b`
          }, {
            begin: "\\b(0|[1-9](_?[0-9])*)n\\b"
          }, {
            begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"
          }, {
            begin: "\\b0[bB][0-1](_?[0-1])*n?\\b"
          }, { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" }, {
            begin: "\\b0[0-7]+n?\\b"
          }],
          relevance: 0
        }, l2 = {
          className: "subst",
          begin: "\\$\\{",
          end: "\\}",
          keywords: i2,
          contains: []
        }, c2 = { begin: "html`", end: "", starts: {
          end: "`",
          returnEnd: false,
          contains: [e2.BACKSLASH_ESCAPE, l2],
          subLanguage: "xml"
        } }, d2 = {
          begin: "css`",
          end: "",
          starts: {
            end: "`",
            returnEnd: false,
            contains: [e2.BACKSLASH_ESCAPE, l2],
            subLanguage: "css"
          }
        }, g2 = {
          className: "string",
          begin: "`",
          end: "`",
          contains: [e2.BACKSLASH_ESCAPE, l2]
        }, u2 = {
          className: "comment",
          variants: [e2.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
            relevance: 0,
            contains: [{
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [{
                className: "doctag",
                begin: "@[A-Za-z]+"
              }, {
                className: "type",
                begin: "\\{",
                end: "\\}",
                excludeEnd: true,
                excludeBegin: true,
                relevance: 0
              }, {
                className: "variable",
                begin: t2 + "(?=\\s*(-)|$)",
                endsParent: true,
                relevance: 0
              }, { begin: /(?=[^\n])\s/, relevance: 0 }]
            }]
          }), e2.C_BLOCK_COMMENT_MODE, e2.C_LINE_COMMENT_MODE]
        }, b2 = [e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, c2, d2, g2, o2];
        l2.contains = b2.concat({
          begin: /\{/,
          end: /\}/,
          keywords: i2,
          contains: ["self"].concat(b2)
        });
        const m2 = [].concat(u2, l2.contains), p2 = m2.concat([{
          begin: /\(/,
          end: /\)/,
          keywords: i2,
          contains: ["self"].concat(m2)
        }]), _2 = {
          className: "params",
          begin: /\(/,
          end: /\)/,
          excludeBegin: true,
          excludeEnd: true,
          keywords: i2,
          contains: p2
        }, h2 = { variants: [{
          match: [/class/, /\s+/, t2, /\s+/, /extends/, /\s+/, n2.concat(t2, "(", n2.concat(/\./, t2), ")*")],
          scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" }
        }, {
          match: [/class/, /\s+/, t2],
          scope: { 1: "keyword", 3: "title.class" }
        }] }, f2 = {
          relevance: 0,
          match: n2.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]+|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+/),
          className: "title.class",
          keywords: { _: [..._e, ...he] }
        }, E2 = {
          variants: [{
            match: [/function/, /\s+/, t2, /(?=\s*\()/]
          }, { match: [/function/, /\s*(?=\()/] }],
          className: { 1: "keyword", 3: "title.function" },
          label: "func.def",
          contains: [_2],
          illegal: /%/
        }, y2 = {
          match: n2.concat(/\b/, (N2 = [...fe, "super"], n2.concat("(?!", N2.join("|"), ")")), t2, n2.lookahead(/\(/)),
          className: "title.function",
          relevance: 0
        };
        var N2;
        const w2 = {
          begin: n2.concat(/\./, n2.lookahead(n2.concat(t2, /(?![0-9A-Za-z$_(])/))),
          end: t2,
          excludeBegin: true,
          keywords: "prototype",
          className: "property",
          relevance: 0
        }, v2 = {
          match: [/get|set/, /\s+/, t2, /(?=\()/],
          className: { 1: "keyword", 3: "title.function" },
          contains: [{ begin: /\(\)/ }, _2]
        }, O2 = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e2.UNDERSCORE_IDENT_RE + ")\\s*=>", x2 = {
          match: [/const|var|let/, /\s+/, t2, /\s*/, /=\s*/, n2.lookahead(O2)],
          className: {
            1: "keyword",
            3: "title.function"
          },
          contains: [_2]
        };
        return {
          name: "Javascript",
          aliases: ["js", "jsx", "mjs", "cjs"],
          keywords: i2,
          exports: {
            PARAMS_CONTAINS: p2,
            CLASS_REFERENCE: f2
          },
          illegal: /#(?![$_A-z])/,
          contains: [e2.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }), {
            label: "use_strict",
            className: "meta",
            relevance: 10,
            begin: /^\s*['"]use (strict|asm)['"]/
          }, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, c2, d2, g2, u2, o2, f2, {
            className: "attr",
            begin: t2 + n2.lookahead(":"),
            relevance: 0
          }, x2, {
            begin: "(" + e2.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [u2, e2.REGEXP_MODE, {
              className: "function",
              begin: O2,
              returnBegin: true,
              end: "\\s*=>",
              contains: [{
                className: "params",
                variants: [{ begin: e2.UNDERSCORE_IDENT_RE, relevance: 0 }, {
                  className: null,
                  begin: /\(\s*\)/,
                  skip: true
                }, {
                  begin: /\(/,
                  end: /\)/,
                  excludeBegin: true,
                  excludeEnd: true,
                  keywords: i2,
                  contains: p2
                }]
              }]
            }, { begin: /,/, relevance: 0 }, {
              match: /\s+/,
              relevance: 0
            }, { variants: [{ begin: "<>", end: "</>" }, {
              match: /<[A-Za-z0-9\\._:-]+\s*\/>/
            }, {
              begin: a2.begin,
              "on:begin": a2.isTrulyOpeningTag,
              end: a2.end
            }], subLanguage: "xml", contains: [{
              begin: a2.begin,
              end: a2.end,
              skip: true,
              contains: ["self"]
            }] }]
          }, E2, {
            beginKeywords: "while if switch catch for"
          }, {
            begin: "\\b(?!function)" + e2.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            returnBegin: true,
            label: "func.def",
            contains: [_2, e2.inherit(e2.TITLE_MODE, {
              begin: t2,
              className: "title.function"
            })]
          }, { match: /\.\.\./, relevance: 0 }, w2, {
            match: "\\$" + t2,
            relevance: 0
          }, {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [_2]
          }, y2, {
            relevance: 0,
            match: /\b[A-Z][A-Z_0-9]+\b/,
            className: "variable.constant"
          }, h2, v2, { match: /\$[(.]/ }]
        };
      }
      const we = (e2) => m(/\b/, e2, /\w$/.test(e2) ? /\b/ : /\B/), ve = ["Protocol", "Type"].map(we), Oe = ["init", "self"].map(we), xe = ["Any", "Self"], Me = ["actor", "associatedtype", "async", "await", /as\?/, /as!/, "as", "break", "case", "catch", "class", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "extension", "fallthrough", /fileprivate\(set\)/, "fileprivate", "final", "for", "func", "get", "guard", "if", "import", "indirect", "infix", /init\?/, /init!/, "inout", /internal\(set\)/, "internal", "in", "is", "isolated", "nonisolated", "lazy", "let", "mutating", "nonmutating", /open\(set\)/, "open", "operator", "optional", "override", "postfix", "precedencegroup", "prefix", /private\(set\)/, "private", "protocol", /public\(set\)/, "public", "repeat", "required", "rethrows", "return", "set", "some", "static", "struct", "subscript", "super", "switch", "throws", "throw", /try\?/, /try!/, "try", "typealias", /unowned\(safe\)/, /unowned\(unsafe\)/, "unowned", "var", "weak", "where", "while", "willSet"], ke = ["false", "nil", "true"], Se = ["assignment", "associativity", "higherThan", "left", "lowerThan", "none", "right"], Ae = ["#colorLiteral", "#column", "#dsohandle", "#else", "#elseif", "#endif", "#error", "#file", "#fileID", "#fileLiteral", "#filePath", "#function", "#if", "#imageLiteral", "#keyPath", "#line", "#selector", "#sourceLocation", "#warn_unqualified_access", "#warning"], Ce = ["abs", "all", "any", "assert", "assertionFailure", "debugPrint", "dump", "fatalError", "getVaList", "isKnownUniquelyReferenced", "max", "min", "numericCast", "pointwiseMax", "pointwiseMin", "precondition", "preconditionFailure", "print", "readLine", "repeatElement", "sequence", "stride", "swap", "swift_unboxFromSwiftValueWithType", "transcode", "type", "unsafeBitCast", "unsafeDowncast", "withExtendedLifetime", "withUnsafeMutablePointer", "withUnsafePointer", "withVaList", "withoutActuallyEscaping", "zip"], Te = p(/[/=\-+!*%<>&|^~?]/, /[\u00A1-\u00A7]/, /[\u00A9\u00AB]/, /[\u00AC\u00AE]/, /[\u00B0\u00B1]/, /[\u00B6\u00BB\u00BF\u00D7\u00F7]/, /[\u2016-\u2017]/, /[\u2020-\u2027]/, /[\u2030-\u203E]/, /[\u2041-\u2053]/, /[\u2055-\u205E]/, /[\u2190-\u23FF]/, /[\u2500-\u2775]/, /[\u2794-\u2BFF]/, /[\u2E00-\u2E7F]/, /[\u3001-\u3003]/, /[\u3008-\u3020]/, /[\u3030]/), Re = p(Te, /[\u0300-\u036F]/, /[\u1DC0-\u1DFF]/, /[\u20D0-\u20FF]/, /[\uFE00-\uFE0F]/, /[\uFE20-\uFE2F]/), De = m(Te, Re, "*"), Ie = p(/[a-zA-Z_]/, /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/, /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/, /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/, /[\u1E00-\u1FFF]/, /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/, /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/, /[\u2C00-\u2DFF\u2E80-\u2FFF]/, /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/, /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/, /[\uFE47-\uFEFE\uFF00-\uFFFD]/), Le = p(Ie, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/), Be = m(Ie, Le, "*"), $e = m(/[A-Z]/, Le, "*"), Fe = ["autoclosure", m(/convention\(/, p("swift", "block", "c"), /\)/), "discardableResult", "dynamicCallable", "dynamicMemberLookup", "escaping", "frozen", "GKInspectable", "IBAction", "IBDesignable", "IBInspectable", "IBOutlet", "IBSegueAction", "inlinable", "main", "nonobjc", "NSApplicationMain", "NSCopying", "NSManaged", m(/objc\(/, Be, /\)/), "objc", "objcMembers", "propertyWrapper", "requires_stored_property_inits", "resultBuilder", "testable", "UIApplicationMain", "unknown", "usableFromInline"], ze = ["iOS", "iOSApplicationExtension", "macOS", "macOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "watchOS", "watchOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "swift"];
      var Ue = Object.freeze({
        __proto__: null,
        grmr_bash: (e2) => {
          const n2 = e2.regex, t2 = {}, a2 = {
            begin: /\$\{/,
            end: /\}/,
            contains: ["self", { begin: /:-/, contains: [t2] }]
          };
          Object.assign(t2, { className: "variable", variants: [{
            begin: n2.concat(/\$[\w\d#@][\w\d_]*/, "(?![\\w\\d])(?![$])")
          }, a2] });
          const i2 = {
            className: "subst",
            begin: /\$\(/,
            end: /\)/,
            contains: [e2.BACKSLASH_ESCAPE]
          }, r2 = {
            begin: /<<-?\s*(?=\w+)/,
            starts: { contains: [e2.END_SAME_AS_BEGIN({
              begin: /(\w+)/,
              end: /(\w+)/,
              className: "string"
            })] }
          }, s2 = {
            className: "string",
            begin: /"/,
            end: /"/,
            contains: [e2.BACKSLASH_ESCAPE, t2, i2]
          };
          i2.contains.push(s2);
          const o2 = {
            begin: /\$\(\(/,
            end: /\)\)/,
            contains: [{ begin: /\d+#[0-9a-f]+/, className: "number" }, e2.NUMBER_MODE, t2]
          }, l2 = e2.SHEBANG({
            binary: "(fish|bash|zsh|sh|csh|ksh|tcsh|dash|scsh)",
            relevance: 10
          }), c2 = {
            className: "function",
            begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
            returnBegin: true,
            contains: [e2.inherit(e2.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
            relevance: 0
          };
          return {
            name: "Bash",
            aliases: ["sh"],
            keywords: {
              $pattern: /\b[a-z._-]+\b/,
              keyword: ["if", "then", "else", "elif", "fi", "for", "while", "in", "do", "done", "case", "esac", "function"],
              literal: ["true", "false"],
              built_in: ["break", "cd", "continue", "eval", "exec", "exit", "export", "getopts", "hash", "pwd", "readonly", "return", "shift", "test", "times", "trap", "umask", "unset", "alias", "bind", "builtin", "caller", "command", "declare", "echo", "enable", "help", "let", "local", "logout", "mapfile", "printf", "read", "readarray", "source", "type", "typeset", "ulimit", "unalias", "set", "shopt", "autoload", "bg", "bindkey", "bye", "cap", "chdir", "clone", "comparguments", "compcall", "compctl", "compdescribe", "compfiles", "compgroups", "compquote", "comptags", "comptry", "compvalues", "dirs", "disable", "disown", "echotc", "echoti", "emulate", "fc", "fg", "float", "functions", "getcap", "getln", "history", "integer", "jobs", "kill", "limit", "log", "noglob", "popd", "print", "pushd", "pushln", "rehash", "sched", "setcap", "setopt", "stat", "suspend", "ttyctl", "unfunction", "unhash", "unlimit", "unsetopt", "vared", "wait", "whence", "where", "which", "zcompile", "zformat", "zftp", "zle", "zmodload", "zparseopts", "zprof", "zpty", "zregexparse", "zsocket", "zstyle", "ztcp", "chcon", "chgrp", "chown", "chmod", "cp", "dd", "df", "dir", "dircolors", "ln", "ls", "mkdir", "mkfifo", "mknod", "mktemp", "mv", "realpath", "rm", "rmdir", "shred", "sync", "touch", "truncate", "vdir", "b2sum", "base32", "base64", "cat", "cksum", "comm", "csplit", "cut", "expand", "fmt", "fold", "head", "join", "md5sum", "nl", "numfmt", "od", "paste", "ptx", "pr", "sha1sum", "sha224sum", "sha256sum", "sha384sum", "sha512sum", "shuf", "sort", "split", "sum", "tac", "tail", "tr", "tsort", "unexpand", "uniq", "wc", "arch", "basename", "chroot", "date", "dirname", "du", "echo", "env", "expr", "factor", "groups", "hostid", "id", "link", "logname", "nice", "nohup", "nproc", "pathchk", "pinky", "printenv", "printf", "pwd", "readlink", "runcon", "seq", "sleep", "stat", "stdbuf", "stty", "tee", "test", "timeout", "tty", "uname", "unlink", "uptime", "users", "who", "whoami", "yes"]
            },
            contains: [l2, e2.SHEBANG(), c2, o2, e2.HASH_COMMENT_MODE, r2, { match: /(\/[a-z._-]+)+/ }, s2, {
              className: "",
              begin: /\\"/
            }, { className: "string", begin: /'/, end: /'/ }, t2]
          };
        },
        grmr_c: (e2) => {
          const n2 = e2.regex, t2 = e2.COMMENT("//", "$", {
            contains: [{ begin: /\\\n/ }]
          }), a2 = "[a-zA-Z_]\\w*::", i2 = "(decltype\\(auto\\)|" + n2.optional(a2) + "[a-zA-Z_]\\w*" + n2.optional("<[^<>]+>") + ")", r2 = {
            className: "type",
            variants: [{ begin: "\\b[a-z\\d_]*_t\\b" }, {
              match: /\batomic_[a-z]{3,6}\b/
            }]
          }, s2 = { className: "string", variants: [{
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [e2.BACKSLASH_ESCAPE]
          }, {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          }, e2.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })] }, o2 = {
            className: "number",
            variants: [{ begin: "\\b(0b[01']+)" }, {
              begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
            }, {
              begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
            }],
            relevance: 0
          }, l2 = { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: {
            keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"
          }, contains: [{ begin: /\\\n/, relevance: 0 }, e2.inherit(s2, { className: "string" }), {
            className: "string",
            begin: /<.*?>/
          }, t2, e2.C_BLOCK_COMMENT_MODE] }, c2 = {
            className: "title",
            begin: n2.optional(a2) + e2.IDENT_RE,
            relevance: 0
          }, d2 = n2.optional(a2) + e2.IDENT_RE + "\\s*\\(", g2 = {
            keyword: ["asm", "auto", "break", "case", "continue", "default", "do", "else", "enum", "extern", "for", "fortran", "goto", "if", "inline", "register", "restrict", "return", "sizeof", "struct", "switch", "typedef", "union", "volatile", "while", "_Alignas", "_Alignof", "_Atomic", "_Generic", "_Noreturn", "_Static_assert", "_Thread_local", "alignas", "alignof", "noreturn", "static_assert", "thread_local", "_Pragma"],
            type: ["float", "double", "signed", "unsigned", "int", "short", "long", "char", "void", "_Bool", "_Complex", "_Imaginary", "_Decimal32", "_Decimal64", "_Decimal128", "const", "static", "complex", "bool", "imaginary"],
            literal: "true false NULL",
            built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
          }, u2 = [l2, r2, t2, e2.C_BLOCK_COMMENT_MODE, o2, s2], b2 = {
            variants: [{ begin: /=/, end: /;/ }, {
              begin: /\(/,
              end: /\)/
            }, { beginKeywords: "new throw return else", end: /;/ }],
            keywords: g2,
            contains: u2.concat([{
              begin: /\(/,
              end: /\)/,
              keywords: g2,
              contains: u2.concat(["self"]),
              relevance: 0
            }]),
            relevance: 0
          }, m2 = {
            begin: "(" + i2 + "[\\*&\\s]+)+" + d2,
            returnBegin: true,
            end: /[{;=]/,
            excludeEnd: true,
            keywords: g2,
            illegal: /[^\w\s\*&:<>.]/,
            contains: [{
              begin: "decltype\\(auto\\)",
              keywords: g2,
              relevance: 0
            }, { begin: d2, returnBegin: true, contains: [e2.inherit(c2, {
              className: "title.function"
            })], relevance: 0 }, { relevance: 0, match: /,/ }, {
              className: "params",
              begin: /\(/,
              end: /\)/,
              keywords: g2,
              relevance: 0,
              contains: [t2, e2.C_BLOCK_COMMENT_MODE, s2, o2, r2, {
                begin: /\(/,
                end: /\)/,
                keywords: g2,
                relevance: 0,
                contains: ["self", t2, e2.C_BLOCK_COMMENT_MODE, s2, o2, r2]
              }]
            }, r2, t2, e2.C_BLOCK_COMMENT_MODE, l2]
          };
          return {
            name: "C",
            aliases: ["h"],
            keywords: g2,
            disableAutodetect: true,
            illegal: "</",
            contains: [].concat(b2, m2, u2, [l2, {
              begin: e2.IDENT_RE + "::",
              keywords: g2
            }, {
              className: "class",
              beginKeywords: "enum class struct union",
              end: /[{;:<>=]/,
              contains: [{
                beginKeywords: "final class struct"
              }, e2.TITLE_MODE]
            }]),
            exports: {
              preprocessor: l2,
              strings: s2,
              keywords: g2
            }
          };
        },
        grmr_cpp: (e2) => {
          const n2 = e2.regex, t2 = e2.COMMENT("//", "$", {
            contains: [{ begin: /\\\n/ }]
          }), a2 = "[a-zA-Z_]\\w*::", i2 = "(?!struct)(decltype\\(auto\\)|" + n2.optional(a2) + "[a-zA-Z_]\\w*" + n2.optional("<[^<>]+>") + ")", r2 = {
            className: "type",
            begin: "\\b[a-z\\d_]*_t\\b"
          }, s2 = { className: "string", variants: [{
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [e2.BACKSLASH_ESCAPE]
          }, {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          }, e2.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })] }, o2 = {
            className: "number",
            variants: [{ begin: "\\b(0b[01']+)" }, {
              begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
            }, {
              begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
            }],
            relevance: 0
          }, l2 = { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: {
            keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"
          }, contains: [{ begin: /\\\n/, relevance: 0 }, e2.inherit(s2, { className: "string" }), {
            className: "string",
            begin: /<.*?>/
          }, t2, e2.C_BLOCK_COMMENT_MODE] }, c2 = {
            className: "title",
            begin: n2.optional(a2) + e2.IDENT_RE,
            relevance: 0
          }, d2 = n2.optional(a2) + e2.IDENT_RE + "\\s*\\(", g2 = {
            type: ["bool", "char", "char16_t", "char32_t", "char8_t", "double", "float", "int", "long", "short", "void", "wchar_t", "unsigned", "signed", "const", "static"],
            keyword: ["alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel", "atomic_commit", "atomic_noexcept", "auto", "bitand", "bitor", "break", "case", "catch", "class", "co_await", "co_return", "co_yield", "compl", "concept", "const_cast|10", "consteval", "constexpr", "constinit", "continue", "decltype", "default", "delete", "do", "dynamic_cast|10", "else", "enum", "explicit", "export", "extern", "false", "final", "for", "friend", "goto", "if", "import", "inline", "module", "mutable", "namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", "or_eq", "override", "private", "protected", "public", "reflexpr", "register", "reinterpret_cast|10", "requires", "return", "sizeof", "static_assert", "static_cast|10", "struct", "switch", "synchronized", "template", "this", "thread_local", "throw", "transaction_safe", "transaction_safe_dynamic", "true", "try", "typedef", "typeid", "typename", "union", "using", "virtual", "volatile", "while", "xor", "xor_eq"],
            literal: ["NULL", "false", "nullopt", "nullptr", "true"],
            built_in: ["_Pragma"],
            _type_hints: ["any", "auto_ptr", "barrier", "binary_semaphore", "bitset", "complex", "condition_variable", "condition_variable_any", "counting_semaphore", "deque", "false_type", "future", "imaginary", "initializer_list", "istringstream", "jthread", "latch", "lock_guard", "multimap", "multiset", "mutex", "optional", "ostringstream", "packaged_task", "pair", "promise", "priority_queue", "queue", "recursive_mutex", "recursive_timed_mutex", "scoped_lock", "set", "shared_future", "shared_lock", "shared_mutex", "shared_timed_mutex", "shared_ptr", "stack", "string_view", "stringstream", "timed_mutex", "thread", "true_type", "tuple", "unique_lock", "unique_ptr", "unordered_map", "unordered_multimap", "unordered_multiset", "unordered_set", "variant", "vector", "weak_ptr", "wstring", "wstring_view"]
          }, u2 = {
            className: "function.dispatch",
            relevance: 0,
            keywords: {
              _hint: ["abort", "abs", "acos", "apply", "as_const", "asin", "atan", "atan2", "calloc", "ceil", "cerr", "cin", "clog", "cos", "cosh", "cout", "declval", "endl", "exchange", "exit", "exp", "fabs", "floor", "fmod", "forward", "fprintf", "fputs", "free", "frexp", "fscanf", "future", "invoke", "isalnum", "isalpha", "iscntrl", "isdigit", "isgraph", "islower", "isprint", "ispunct", "isspace", "isupper", "isxdigit", "labs", "launder", "ldexp", "log", "log10", "make_pair", "make_shared", "make_shared_for_overwrite", "make_tuple", "make_unique", "malloc", "memchr", "memcmp", "memcpy", "memset", "modf", "move", "pow", "printf", "putchar", "puts", "realloc", "scanf", "sin", "sinh", "snprintf", "sprintf", "sqrt", "sscanf", "std", "stderr", "stdin", "stdout", "strcat", "strchr", "strcmp", "strcpy", "strcspn", "strlen", "strncat", "strncmp", "strncpy", "strpbrk", "strrchr", "strspn", "strstr", "swap", "tan", "tanh", "terminate", "to_underlying", "tolower", "toupper", "vfprintf", "visit", "vprintf", "vsprintf"]
            },
            begin: n2.concat(/\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, e2.IDENT_RE, n2.lookahead(/(<[^<>]+>|)\s*\(/))
          }, b2 = [u2, l2, r2, t2, e2.C_BLOCK_COMMENT_MODE, o2, s2], m2 = {
            variants: [{ begin: /=/, end: /;/ }, {
              begin: /\(/,
              end: /\)/
            }, { beginKeywords: "new throw return else", end: /;/ }],
            keywords: g2,
            contains: b2.concat([{
              begin: /\(/,
              end: /\)/,
              keywords: g2,
              contains: b2.concat(["self"]),
              relevance: 0
            }]),
            relevance: 0
          }, p2 = {
            className: "function",
            begin: "(" + i2 + "[\\*&\\s]+)+" + d2,
            returnBegin: true,
            end: /[{;=]/,
            excludeEnd: true,
            keywords: g2,
            illegal: /[^\w\s\*&:<>.]/,
            contains: [{
              begin: "decltype\\(auto\\)",
              keywords: g2,
              relevance: 0
            }, { begin: d2, returnBegin: true, contains: [c2], relevance: 0 }, {
              begin: /::/,
              relevance: 0
            }, { begin: /:/, endsWithParent: true, contains: [s2, o2] }, {
              relevance: 0,
              match: /,/
            }, {
              className: "params",
              begin: /\(/,
              end: /\)/,
              keywords: g2,
              relevance: 0,
              contains: [t2, e2.C_BLOCK_COMMENT_MODE, s2, o2, r2, {
                begin: /\(/,
                end: /\)/,
                keywords: g2,
                relevance: 0,
                contains: ["self", t2, e2.C_BLOCK_COMMENT_MODE, s2, o2, r2]
              }]
            }, r2, t2, e2.C_BLOCK_COMMENT_MODE, l2]
          };
          return {
            name: "C++",
            aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"],
            keywords: g2,
            illegal: "</",
            classNameAliases: { "function.dispatch": "built_in" },
            contains: [].concat(m2, p2, u2, b2, [l2, {
              begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<",
              end: ">",
              keywords: g2,
              contains: ["self", r2]
            }, { begin: e2.IDENT_RE + "::", keywords: g2 }, {
              match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/],
              className: { 1: "keyword", 3: "title.class" }
            }])
          };
        },
        grmr_csharp: (e2) => {
          const n2 = {
            keyword: ["abstract", "as", "base", "break", "case", "catch", "class", "const", "continue", "do", "else", "event", "explicit", "extern", "finally", "fixed", "for", "foreach", "goto", "if", "implicit", "in", "interface", "internal", "is", "lock", "namespace", "new", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "record", "ref", "return", "sealed", "sizeof", "stackalloc", "static", "struct", "switch", "this", "throw", "try", "typeof", "unchecked", "unsafe", "using", "virtual", "void", "volatile", "while"].concat(["add", "alias", "and", "ascending", "async", "await", "by", "descending", "equals", "from", "get", "global", "group", "init", "into", "join", "let", "nameof", "not", "notnull", "on", "or", "orderby", "partial", "remove", "select", "set", "unmanaged", "value|0", "var", "when", "where", "with", "yield"]),
            built_in: ["bool", "byte", "char", "decimal", "delegate", "double", "dynamic", "enum", "float", "int", "long", "nint", "nuint", "object", "sbyte", "short", "string", "ulong", "uint", "ushort"],
            literal: ["default", "false", "null", "true"]
          }, t2 = e2.inherit(e2.TITLE_MODE, {
            begin: "[a-zA-Z](\\.?\\w)*"
          }), a2 = { className: "number", variants: [{
            begin: "\\b(0b[01']+)"
          }, {
            begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"
          }, {
            begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
          }], relevance: 0 }, i2 = {
            className: "string",
            begin: '@"',
            end: '"',
            contains: [{ begin: '""' }]
          }, r2 = e2.inherit(i2, { illegal: /\n/ }), s2 = {
            className: "subst",
            begin: /\{/,
            end: /\}/,
            keywords: n2
          }, o2 = e2.inherit(s2, { illegal: /\n/ }), l2 = {
            className: "string",
            begin: /\$"/,
            end: '"',
            illegal: /\n/,
            contains: [{ begin: /\{\{/ }, {
              begin: /\}\}/
            }, e2.BACKSLASH_ESCAPE, o2]
          }, c2 = { className: "string", begin: /\$@"/, end: '"', contains: [{
            begin: /\{\{/
          }, { begin: /\}\}/ }, { begin: '""' }, s2] }, d2 = e2.inherit(c2, {
            illegal: /\n/,
            contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, o2]
          });
          s2.contains = [c2, l2, i2, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, a2, e2.C_BLOCK_COMMENT_MODE], o2.contains = [d2, l2, r2, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, a2, e2.inherit(e2.C_BLOCK_COMMENT_MODE, {
            illegal: /\n/
          })];
          const g2 = {
            variants: [c2, l2, i2, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE]
          }, u2 = {
            begin: "<",
            end: ">",
            contains: [{ beginKeywords: "in out" }, t2]
          }, b2 = e2.IDENT_RE + "(<" + e2.IDENT_RE + "(\\s*,\\s*" + e2.IDENT_RE + ")*>)?(\\[\\])?", m2 = {
            begin: "@" + e2.IDENT_RE,
            relevance: 0
          };
          return {
            name: "C#",
            aliases: ["cs", "c#"],
            keywords: n2,
            illegal: /::/,
            contains: [e2.COMMENT("///", "$", {
              returnBegin: true,
              contains: [{ className: "doctag", variants: [{ begin: "///", relevance: 0 }, {
                begin: "<!--|-->"
              }, { begin: "</?", end: ">" }] }]
            }), e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, {
              className: "meta",
              begin: "#",
              end: "$",
              keywords: {
                keyword: "if else elif endif define undef warning error line region endregion pragma checksum"
              }
            }, g2, a2, {
              beginKeywords: "class interface",
              relevance: 0,
              end: /[{;=]/,
              illegal: /[^\s:,]/,
              contains: [{
                beginKeywords: "where class"
              }, t2, u2, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
            }, {
              beginKeywords: "namespace",
              relevance: 0,
              end: /[{;=]/,
              illegal: /[^\s:]/,
              contains: [t2, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
            }, {
              beginKeywords: "record",
              relevance: 0,
              end: /[{;=]/,
              illegal: /[^\s:]/,
              contains: [t2, u2, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
            }, {
              className: "meta",
              begin: "^\\s*\\[(?=[\\w])",
              excludeBegin: true,
              end: "\\]",
              excludeEnd: true,
              contains: [{
                className: "string",
                begin: /"/,
                end: /"/
              }]
            }, {
              beginKeywords: "new return throw await else",
              relevance: 0
            }, {
              className: "function",
              begin: "(" + b2 + "\\s+)+" + e2.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
              returnBegin: true,
              end: /\s*[{;=]/,
              excludeEnd: true,
              keywords: n2,
              contains: [{
                beginKeywords: "public private protected static internal protected abstract async extern override unsafe virtual new sealed partial",
                relevance: 0
              }, {
                begin: e2.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                returnBegin: true,
                contains: [e2.TITLE_MODE, u2],
                relevance: 0
              }, { match: /\(\)/ }, {
                className: "params",
                begin: /\(/,
                end: /\)/,
                excludeBegin: true,
                excludeEnd: true,
                keywords: n2,
                relevance: 0,
                contains: [g2, a2, e2.C_BLOCK_COMMENT_MODE]
              }, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
            }, m2]
          };
        },
        grmr_css: (e2) => {
          const n2 = e2.regex, t2 = te(e2), a2 = [e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE];
          return {
            name: "CSS",
            case_insensitive: true,
            illegal: /[=|'\$]/,
            keywords: {
              keyframePosition: "from to"
            },
            classNameAliases: { keyframePosition: "selector-tag" },
            contains: [t2.BLOCK_COMMENT, {
              begin: /-(webkit|moz|ms|o)-(?=[a-z])/
            }, t2.CSS_NUMBER_MODE, {
              className: "selector-id",
              begin: /#[A-Za-z0-9_-]+/,
              relevance: 0
            }, {
              className: "selector-class",
              begin: "\\.[a-zA-Z-][a-zA-Z0-9_-]*",
              relevance: 0
            }, t2.ATTRIBUTE_SELECTOR_MODE, {
              className: "selector-pseudo",
              variants: [{
                begin: ":(" + re.join("|") + ")"
              }, { begin: ":(:)?(" + se.join("|") + ")" }]
            }, t2.CSS_VARIABLE, { className: "attribute", begin: "\\b(" + oe.join("|") + ")\\b" }, {
              begin: /:/,
              end: /[;}{]/,
              contains: [t2.BLOCK_COMMENT, t2.HEXCOLOR, t2.IMPORTANT, t2.CSS_NUMBER_MODE, ...a2, {
                begin: /(url|data-uri)\(/,
                end: /\)/,
                relevance: 0,
                keywords: {
                  built_in: "url data-uri"
                },
                contains: [{ className: "string", begin: /[^)]/, endsWithParent: true, excludeEnd: true }]
              }, t2.FUNCTION_DISPATCH]
            }, {
              begin: n2.lookahead(/@/),
              end: "[{;]",
              relevance: 0,
              illegal: /:/,
              contains: [{ className: "keyword", begin: /@-?\w[\w]*(-\w+)*/ }, {
                begin: /\s/,
                endsWithParent: true,
                excludeEnd: true,
                relevance: 0,
                keywords: {
                  $pattern: /[a-z-]+/,
                  keyword: "and or not only",
                  attribute: ie.join(" ")
                },
                contains: [{
                  begin: /[a-z-]+(?=:)/,
                  className: "attribute"
                }, ...a2, t2.CSS_NUMBER_MODE]
              }]
            }, {
              className: "selector-tag",
              begin: "\\b(" + ae.join("|") + ")\\b"
            }]
          };
        },
        grmr_diff: (e2) => {
          const n2 = e2.regex;
          return { name: "Diff", aliases: ["patch"], contains: [{
            className: "meta",
            relevance: 10,
            match: n2.either(/^@@ +-\d+,\d+ +\+\d+,\d+ +@@/, /^\*\*\* +\d+,\d+ +\*\*\*\*$/, /^--- +\d+,\d+ +----$/)
          }, { className: "comment", variants: [{
            begin: n2.either(/Index: /, /^index/, /={3,}/, /^-{3}/, /^\*{3} /, /^\+{3}/, /^diff --git/),
            end: /$/
          }, { match: /^\*{15}$/ }] }, { className: "addition", begin: /^\+/, end: /$/ }, {
            className: "deletion",
            begin: /^-/,
            end: /$/
          }, {
            className: "addition",
            begin: /^!/,
            end: /$/
          }] };
        },
        grmr_go: (e2) => {
          const n2 = {
            keyword: ["break", "case", "chan", "const", "continue", "default", "defer", "else", "fallthrough", "for", "func", "go", "goto", "if", "import", "interface", "map", "package", "range", "return", "select", "struct", "switch", "type", "var"],
            type: ["bool", "byte", "complex64", "complex128", "error", "float32", "float64", "int8", "int16", "int32", "int64", "string", "uint8", "uint16", "uint32", "uint64", "int", "uint", "uintptr", "rune"],
            literal: ["true", "false", "iota", "nil"],
            built_in: ["append", "cap", "close", "complex", "copy", "imag", "len", "make", "new", "panic", "print", "println", "real", "recover", "delete"]
          };
          return {
            name: "Go",
            aliases: ["golang"],
            keywords: n2,
            illegal: "</",
            contains: [e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, {
              className: "string",
              variants: [e2.QUOTE_STRING_MODE, e2.APOS_STRING_MODE, { begin: "`", end: "`" }]
            }, {
              className: "number",
              variants: [{
                begin: e2.C_NUMBER_RE + "[i]",
                relevance: 1
              }, e2.C_NUMBER_MODE]
            }, { begin: /:=/ }, {
              className: "function",
              beginKeywords: "func",
              end: "\\s*(\\{|$)",
              excludeEnd: true,
              contains: [e2.TITLE_MODE, {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: n2,
                illegal: /["']/
              }]
            }]
          };
        },
        grmr_ini: (e2) => {
          const n2 = e2.regex, t2 = { className: "number", relevance: 0, variants: [{
            begin: /([+-]+)?[\d]+_[\d_]+/
          }, { begin: e2.NUMBER_RE }] }, a2 = e2.COMMENT();
          a2.variants = [{
            begin: /;/,
            end: /$/
          }, { begin: /#/, end: /$/ }];
          const i2 = {
            className: "variable",
            variants: [{ begin: /\$[\w\d"][\w\d_]*/ }, { begin: /\$\{(.*?)\}/ }]
          }, r2 = {
            className: "literal",
            begin: /\bon|off|true|false|yes|no\b/
          }, s2 = {
            className: "string",
            contains: [e2.BACKSLASH_ESCAPE],
            variants: [{ begin: "'''", end: "'''", relevance: 10 }, {
              begin: '"""',
              end: '"""',
              relevance: 10
            }, { begin: '"', end: '"' }, { begin: "'", end: "'" }]
          }, o2 = {
            begin: /\[/,
            end: /\]/,
            contains: [a2, r2, i2, s2, t2, "self"],
            relevance: 0
          }, l2 = n2.either(/[A-Za-z0-9_-]+/, /"(\\"|[^"])*"/, /'[^']*'/);
          return {
            name: "TOML, also INI",
            aliases: ["toml"],
            case_insensitive: true,
            illegal: /\S/,
            contains: [a2, { className: "section", begin: /\[+/, end: /\]+/ }, {
              begin: n2.concat(l2, "(\\s*\\.\\s*", l2, ")*", n2.lookahead(/\s*=\s*[^#\s]/)),
              className: "attr",
              starts: { end: /$/, contains: [a2, o2, r2, i2, s2, t2] }
            }]
          };
        },
        grmr_java: (e2) => {
          e2.regex;
          const n2 = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*", t2 = n2 + ue("(?:<" + n2 + "~~~(?:\\s*,\\s*" + n2 + "~~~)*>)?", /~~~/g, 2), a2 = {
            keyword: ["synchronized", "abstract", "private", "var", "static", "if", "const ", "for", "while", "strictfp", "finally", "protected", "import", "native", "final", "void", "enum", "else", "break", "transient", "catch", "instanceof", "volatile", "case", "assert", "package", "default", "public", "try", "switch", "continue", "throws", "protected", "public", "private", "module", "requires", "exports", "do"],
            literal: ["false", "true", "null"],
            type: ["char", "boolean", "long", "float", "int", "byte", "short", "double"],
            built_in: ["super", "this"]
          }, i2 = { className: "meta", begin: "@" + n2, contains: [{
            begin: /\(/,
            end: /\)/,
            contains: ["self"]
          }] }, r2 = {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: a2,
            relevance: 0,
            contains: [e2.C_BLOCK_COMMENT_MODE],
            endsParent: true
          };
          return {
            name: "Java",
            aliases: ["jsp"],
            keywords: a2,
            illegal: /<\/|#/,
            contains: [e2.COMMENT("/\\*\\*", "\\*/", { relevance: 0, contains: [{
              begin: /\w+@/,
              relevance: 0
            }, { className: "doctag", begin: "@[A-Za-z]+" }] }), {
              begin: /import java\.[a-z]+\./,
              keywords: "import",
              relevance: 2
            }, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, {
              begin: /"""/,
              end: /"""/,
              className: "string",
              contains: [e2.BACKSLASH_ESCAPE]
            }, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, {
              match: [/\b(?:class|interface|enum|extends|implements|new)/, /\s+/, n2],
              className: {
                1: "keyword",
                3: "title.class"
              }
            }, { begin: [n2, /\s+/, n2, /\s+/, /=/], className: {
              1: "type",
              3: "variable",
              5: "operator"
            } }, { begin: [/record/, /\s+/, n2], className: {
              1: "keyword",
              3: "title.class"
            }, contains: [r2, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE] }, {
              beginKeywords: "new throw return else",
              relevance: 0
            }, {
              begin: ["(?:" + t2 + "\\s+)", e2.UNDERSCORE_IDENT_RE, /\s*(?=\()/],
              className: {
                2: "title.function"
              },
              keywords: a2,
              contains: [{
                className: "params",
                begin: /\(/,
                end: /\)/,
                keywords: a2,
                relevance: 0,
                contains: [i2, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, ge, e2.C_BLOCK_COMMENT_MODE]
              }, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
            }, ge, i2]
          };
        },
        grmr_javascript: Ne,
        grmr_json: (e2) => ({ name: "JSON", contains: [{
          className: "attr",
          begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
          relevance: 1.01
        }, {
          match: /[{}[\],:]/,
          className: "punctuation",
          relevance: 0
        }, e2.QUOTE_STRING_MODE, {
          beginKeywords: "true false null"
        }, e2.C_NUMBER_MODE, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE], illegal: "\\S" }),
        grmr_kotlin: (e2) => {
          const n2 = {
            keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
            built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
            literal: "true false null"
          }, t2 = {
            className: "symbol",
            begin: e2.UNDERSCORE_IDENT_RE + "@"
          }, a2 = { className: "subst", begin: /\$\{/, end: /\}/, contains: [e2.C_NUMBER_MODE] }, i2 = {
            className: "variable",
            begin: "\\$" + e2.UNDERSCORE_IDENT_RE
          }, r2 = {
            className: "string",
            variants: [{ begin: '"""', end: '"""(?=[^"])', contains: [i2, a2] }, {
              begin: "'",
              end: "'",
              illegal: /\n/,
              contains: [e2.BACKSLASH_ESCAPE]
            }, {
              begin: '"',
              end: '"',
              illegal: /\n/,
              contains: [e2.BACKSLASH_ESCAPE, i2, a2]
            }]
          };
          a2.contains.push(r2);
          const s2 = {
            className: "meta",
            begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + e2.UNDERSCORE_IDENT_RE + ")?"
          }, o2 = {
            className: "meta",
            begin: "@" + e2.UNDERSCORE_IDENT_RE,
            contains: [{
              begin: /\(/,
              end: /\)/,
              contains: [e2.inherit(r2, { className: "string" })]
            }]
          }, l2 = ge, c2 = e2.COMMENT("/\\*", "\\*/", { contains: [e2.C_BLOCK_COMMENT_MODE] }), d2 = {
            variants: [{ className: "type", begin: e2.UNDERSCORE_IDENT_RE }, {
              begin: /\(/,
              end: /\)/,
              contains: []
            }]
          }, g2 = d2;
          return g2.variants[1].contains = [d2], d2.variants[1].contains = [g2], {
            name: "Kotlin",
            aliases: ["kt", "kts"],
            keywords: n2,
            contains: [e2.COMMENT("/\\*\\*", "\\*/", { relevance: 0, contains: [{
              className: "doctag",
              begin: "@[A-Za-z]+"
            }] }), e2.C_LINE_COMMENT_MODE, c2, {
              className: "keyword",
              begin: /\b(break|continue|return|this)\b/,
              starts: { contains: [{
                className: "symbol",
                begin: /@\w+/
              }] }
            }, t2, s2, o2, {
              className: "function",
              beginKeywords: "fun",
              end: "[(]|$",
              returnBegin: true,
              excludeEnd: true,
              keywords: n2,
              relevance: 5,
              contains: [{
                begin: e2.UNDERSCORE_IDENT_RE + "\\s*\\(",
                returnBegin: true,
                relevance: 0,
                contains: [e2.UNDERSCORE_TITLE_MODE]
              }, {
                className: "type",
                begin: /</,
                end: />/,
                keywords: "reified",
                relevance: 0
              }, {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: n2,
                relevance: 0,
                contains: [{
                  begin: /:/,
                  end: /[=,\/]/,
                  endsWithParent: true,
                  contains: [d2, e2.C_LINE_COMMENT_MODE, c2],
                  relevance: 0
                }, e2.C_LINE_COMMENT_MODE, c2, s2, o2, r2, e2.C_NUMBER_MODE]
              }, c2]
            }, {
              className: "class",
              beginKeywords: "class interface trait",
              end: /[:\{(]|$/,
              excludeEnd: true,
              illegal: "extends implements",
              contains: [{
                beginKeywords: "public protected internal private constructor"
              }, e2.UNDERSCORE_TITLE_MODE, {
                className: "type",
                begin: /</,
                end: />/,
                excludeBegin: true,
                excludeEnd: true,
                relevance: 0
              }, {
                className: "type",
                begin: /[,:]\s*/,
                end: /[<\(,]|$/,
                excludeBegin: true,
                returnEnd: true
              }, s2, o2]
            }, r2, {
              className: "meta",
              begin: "^#!/usr/bin/env",
              end: "$",
              illegal: "\n"
            }, l2]
          };
        },
        grmr_less: (e2) => {
          const n2 = te(e2), t2 = le, a2 = "([\\w-]+|@\\{[\\w-]+\\})", i2 = [], r2 = [], s2 = (e3) => ({
            className: "string",
            begin: "~?" + e3 + ".*?" + e3
          }), o2 = (e3, n3, t3) => ({
            className: e3,
            begin: n3,
            relevance: t3
          }), l2 = {
            $pattern: /[a-z-]+/,
            keyword: "and or not only",
            attribute: ie.join(" ")
          }, c2 = {
            begin: "\\(",
            end: "\\)",
            contains: r2,
            keywords: l2,
            relevance: 0
          };
          r2.push(e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, s2("'"), s2('"'), n2.CSS_NUMBER_MODE, {
            begin: "(url|data-uri)\\(",
            starts: {
              className: "string",
              end: "[\\)\\n]",
              excludeEnd: true
            }
          }, n2.HEXCOLOR, c2, o2("variable", "@@?[\\w-]+", 10), o2("variable", "@\\{[\\w-]+\\}"), o2("built_in", "~?`[^`]*?`"), {
            className: "attribute",
            begin: "[\\w-]+\\s*:",
            end: ":",
            returnBegin: true,
            excludeEnd: true
          }, n2.IMPORTANT);
          const d2 = r2.concat({ begin: /\{/, end: /\}/, contains: i2 }), g2 = {
            beginKeywords: "when",
            endsWithParent: true,
            contains: [{
              beginKeywords: "and not"
            }].concat(r2)
          }, u2 = {
            begin: a2 + "\\s*:",
            returnBegin: true,
            end: /[;}]/,
            relevance: 0,
            contains: [{ begin: /-(webkit|moz|ms|o)-/ }, n2.CSS_VARIABLE, {
              className: "attribute",
              begin: "\\b(" + oe.join("|") + ")\\b",
              end: /(?=:)/,
              starts: {
                endsWithParent: true,
                illegal: "[<=$]",
                relevance: 0,
                contains: r2
              }
            }]
          }, b2 = {
            className: "keyword",
            begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
            starts: { end: "[;{}]", keywords: l2, returnEnd: true, contains: r2, relevance: 0 }
          }, m2 = {
            className: "variable",
            variants: [{ begin: "@[\\w-]+\\s*:", relevance: 15 }, {
              begin: "@[\\w-]+"
            }],
            starts: { end: "[;}]", returnEnd: true, contains: d2 }
          }, p2 = {
            variants: [{
              begin: "[\\.#:&\\[>]",
              end: "[;{}]"
            }, { begin: a2, end: /\{/ }],
            returnBegin: true,
            returnEnd: true,
            illegal: `[<='$"]`,
            relevance: 0,
            contains: [e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, g2, o2("keyword", "all\\b"), o2("variable", "@\\{[\\w-]+\\}"), {
              begin: "\\b(" + ae.join("|") + ")\\b",
              className: "selector-tag"
            }, n2.CSS_NUMBER_MODE, o2("selector-tag", a2, 0), o2("selector-id", "#" + a2), o2("selector-class", "\\." + a2, 0), o2("selector-tag", "&", 0), n2.ATTRIBUTE_SELECTOR_MODE, {
              className: "selector-pseudo",
              begin: ":(" + re.join("|") + ")"
            }, {
              className: "selector-pseudo",
              begin: ":(:)?(" + se.join("|") + ")"
            }, {
              begin: /\(/,
              end: /\)/,
              relevance: 0,
              contains: d2
            }, { begin: "!important" }, n2.FUNCTION_DISPATCH]
          }, _2 = {
            begin: `[\\w-]+:(:)?(${t2.join("|")})`,
            returnBegin: true,
            contains: [p2]
          };
          return i2.push(e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, b2, m2, _2, u2, p2), {
            name: "Less",
            case_insensitive: true,
            illegal: `[=>'/<($"]`,
            contains: i2
          };
        },
        grmr_lua: (e2) => {
          const n2 = "\\[=*\\[", t2 = "\\]=*\\]", a2 = {
            begin: n2,
            end: t2,
            contains: ["self"]
          }, i2 = [e2.COMMENT("--(?!\\[=*\\[)", "$"), e2.COMMENT("--\\[=*\\[", t2, {
            contains: [a2],
            relevance: 10
          })];
          return { name: "Lua", keywords: {
            $pattern: e2.UNDERSCORE_IDENT_RE,
            literal: "true false nil",
            keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
            built_in: "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
          }, contains: i2.concat([{
            className: "function",
            beginKeywords: "function",
            end: "\\)",
            contains: [e2.inherit(e2.TITLE_MODE, {
              begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*"
            }), {
              className: "params",
              begin: "\\(",
              endsWithParent: true,
              contains: i2
            }].concat(i2)
          }, e2.C_NUMBER_MODE, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, {
            className: "string",
            begin: n2,
            end: t2,
            contains: [a2],
            relevance: 5
          }]) };
        },
        grmr_makefile: (e2) => {
          const n2 = {
            className: "variable",
            variants: [{
              begin: "\\$\\(" + e2.UNDERSCORE_IDENT_RE + "\\)",
              contains: [e2.BACKSLASH_ESCAPE]
            }, { begin: /\$[@%<?\^\+\*]/ }]
          }, t2 = {
            className: "string",
            begin: /"/,
            end: /"/,
            contains: [e2.BACKSLASH_ESCAPE, n2]
          }, a2 = {
            className: "variable",
            begin: /\$\([\w-]+\s/,
            end: /\)/,
            keywords: {
              built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value"
            },
            contains: [n2]
          }, i2 = { begin: "^" + e2.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, r2 = {
            className: "section",
            begin: /^[^\s]+:/,
            end: /$/,
            contains: [n2]
          };
          return {
            name: "Makefile",
            aliases: ["mk", "mak", "make"],
            keywords: {
              $pattern: /[\w-]+/,
              keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
            },
            contains: [e2.HASH_COMMENT_MODE, n2, t2, a2, i2, {
              className: "meta",
              begin: /^\.PHONY:/,
              end: /$/,
              keywords: { $pattern: /[\.\w]+/, keyword: ".PHONY" }
            }, r2]
          };
        },
        grmr_xml: (e2) => {
          const n2 = e2.regex, t2 = n2.concat(/[A-Z_]/, n2.optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/), a2 = {
            className: "symbol",
            begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
          }, i2 = {
            begin: /\s/,
            contains: [{ className: "keyword", begin: /#?[a-z_][a-z1-9_-]+/, illegal: /\n/ }]
          }, r2 = e2.inherit(i2, { begin: /\(/, end: /\)/ }), s2 = e2.inherit(e2.APOS_STRING_MODE, {
            className: "string"
          }), o2 = e2.inherit(e2.QUOTE_STRING_MODE, { className: "string" }), l2 = {
            endsWithParent: true,
            illegal: /</,
            relevance: 0,
            contains: [{
              className: "attr",
              begin: /[A-Za-z0-9._:-]+/,
              relevance: 0
            }, { begin: /=\s*/, relevance: 0, contains: [{
              className: "string",
              endsParent: true,
              variants: [{ begin: /"/, end: /"/, contains: [a2] }, {
                begin: /'/,
                end: /'/,
                contains: [a2]
              }, { begin: /[^\s"'=<>`]+/ }]
            }] }]
          };
          return {
            name: "HTML, XML",
            aliases: ["html", "xhtml", "rss", "atom", "xjb", "xsd", "xsl", "plist", "wsf", "svg"],
            case_insensitive: true,
            contains: [{
              className: "meta",
              begin: /<![a-z]/,
              end: />/,
              relevance: 10,
              contains: [i2, o2, s2, r2, { begin: /\[/, end: /\]/, contains: [{
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [i2, r2, o2, s2]
              }] }]
            }, e2.COMMENT(/<!--/, /-->/, {
              relevance: 10
            }), { begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 }, a2, {
              className: "meta",
              begin: /<\?xml/,
              end: /\?>/,
              relevance: 10
            }, {
              className: "tag",
              begin: /<style(?=\s|>)/,
              end: />/,
              keywords: { name: "style" },
              contains: [l2],
              starts: {
                end: /<\/style>/,
                returnEnd: true,
                subLanguage: ["css", "xml"]
              }
            }, {
              className: "tag",
              begin: /<script(?=\s|>)/,
              end: />/,
              keywords: { name: "script" },
              contains: [l2],
              starts: {
                end: /<\/script>/,
                returnEnd: true,
                subLanguage: ["javascript", "handlebars", "xml"]
              }
            }, {
              className: "tag",
              begin: /<>|<\/>/
            }, {
              className: "tag",
              begin: n2.concat(/</, n2.lookahead(n2.concat(t2, n2.either(/\/>/, />/, /\s/)))),
              end: /\/?>/,
              contains: [{ className: "name", begin: t2, relevance: 0, starts: l2 }]
            }, {
              className: "tag",
              begin: n2.concat(/<\//, n2.lookahead(n2.concat(t2, />/))),
              contains: [{
                className: "name",
                begin: t2,
                relevance: 0
              }, { begin: />/, relevance: 0, endsParent: true }]
            }]
          };
        },
        grmr_markdown: (e2) => {
          const n2 = {
            begin: /<\/?[A-Za-z_]/,
            end: ">",
            subLanguage: "xml",
            relevance: 0
          }, t2 = { variants: [{ begin: /\[.+?\]\[.*?\]/, relevance: 0 }, {
            begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
            relevance: 2
          }, {
            begin: e2.regex.concat(/\[.+?\]\(/, /[A-Za-z][A-Za-z0-9+.-]*/, /:\/\/.*?\)/),
            relevance: 2
          }, { begin: /\[.+?\]\([./?&#].*?\)/, relevance: 1 }, {
            begin: /\[.*?\]\(.*?\)/,
            relevance: 0
          }], returnBegin: true, contains: [{
            match: /\[(?=\])/
          }, {
            className: "string",
            relevance: 0,
            begin: "\\[",
            end: "\\]",
            excludeBegin: true,
            returnEnd: true
          }, {
            className: "link",
            relevance: 0,
            begin: "\\]\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true
          }, {
            className: "symbol",
            relevance: 0,
            begin: "\\]\\[",
            end: "\\]",
            excludeBegin: true,
            excludeEnd: true
          }] }, a2 = {
            className: "strong",
            contains: [],
            variants: [{ begin: /_{2}/, end: /_{2}/ }, { begin: /\*{2}/, end: /\*{2}/ }]
          }, i2 = {
            className: "emphasis",
            contains: [],
            variants: [{ begin: /\*(?!\*)/, end: /\*/ }, {
              begin: /_(?!_)/,
              end: /_/,
              relevance: 0
            }]
          };
          a2.contains.push(i2), i2.contains.push(a2);
          let r2 = [n2, t2];
          return a2.contains = a2.contains.concat(r2), i2.contains = i2.contains.concat(r2), r2 = r2.concat(a2, i2), { name: "Markdown", aliases: ["md", "mkdown", "mkd"], contains: [{
            className: "section",
            variants: [{ begin: "^#{1,6}", end: "$", contains: r2 }, {
              begin: "(?=^.+?\\n[=-]{2,}$)",
              contains: [{ begin: "^[=-]*$" }, {
                begin: "^",
                end: "\\n",
                contains: r2
              }]
            }]
          }, n2, {
            className: "bullet",
            begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
            end: "\\s+",
            excludeEnd: true
          }, a2, i2, {
            className: "quote",
            begin: "^>\\s+",
            contains: r2,
            end: "$"
          }, { className: "code", variants: [{ begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" }, {
            begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*"
          }, { begin: "```", end: "```+[ ]*$" }, {
            begin: "~~~",
            end: "~~~+[ ]*$"
          }, { begin: "`.+?`" }, {
            begin: "(?=^( {4}|\\t))",
            contains: [{ begin: "^( {4}|\\t)", end: "(\\n)$" }],
            relevance: 0
          }] }, {
            begin: "^[-\\*]{3,}",
            end: "$"
          }, t2, { begin: /^\[[^\n]+\]:/, returnBegin: true, contains: [{
            className: "symbol",
            begin: /\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true
          }, {
            className: "link",
            begin: /:\s*/,
            end: /$/,
            excludeBegin: true
          }] }] };
        },
        grmr_objectivec: (e2) => {
          const n2 = /[a-zA-Z@][a-zA-Z0-9_]*/, t2 = {
            $pattern: n2,
            keyword: ["@interface", "@class", "@protocol", "@implementation"]
          };
          return {
            name: "Objective-C",
            aliases: ["mm", "objc", "obj-c", "obj-c++", "objective-c++"],
            keywords: {
              $pattern: n2,
              keyword: ["int", "float", "while", "char", "export", "sizeof", "typedef", "const", "struct", "for", "union", "unsigned", "long", "volatile", "static", "bool", "mutable", "if", "do", "return", "goto", "void", "enum", "else", "break", "extern", "asm", "case", "short", "default", "double", "register", "explicit", "signed", "typename", "this", "switch", "continue", "wchar_t", "inline", "readonly", "assign", "readwrite", "self", "@synchronized", "id", "typeof", "nonatomic", "super", "unichar", "IBOutlet", "IBAction", "strong", "weak", "copy", "in", "out", "inout", "bycopy", "byref", "oneway", "__strong", "__weak", "__block", "__autoreleasing", "@private", "@protected", "@public", "@try", "@property", "@end", "@throw", "@catch", "@finally", "@autoreleasepool", "@synthesize", "@dynamic", "@selector", "@optional", "@required", "@encode", "@package", "@import", "@defs", "@compatibility_alias", "__bridge", "__bridge_transfer", "__bridge_retained", "__bridge_retain", "__covariant", "__contravariant", "__kindof", "_Nonnull", "_Nullable", "_Null_unspecified", "__FUNCTION__", "__PRETTY_FUNCTION__", "__attribute__", "getter", "setter", "retain", "unsafe_unretained", "nonnull", "nullable", "null_unspecified", "null_resettable", "class", "instancetype", "NS_DESIGNATED_INITIALIZER", "NS_UNAVAILABLE", "NS_REQUIRES_SUPER", "NS_RETURNS_INNER_POINTER", "NS_INLINE", "NS_AVAILABLE", "NS_DEPRECATED", "NS_ENUM", "NS_OPTIONS", "NS_SWIFT_UNAVAILABLE", "NS_ASSUME_NONNULL_BEGIN", "NS_ASSUME_NONNULL_END", "NS_REFINED_FOR_SWIFT", "NS_SWIFT_NAME", "NS_SWIFT_NOTHROW", "NS_DURING", "NS_HANDLER", "NS_ENDHANDLER", "NS_VALUERETURN", "NS_VOIDRETURN"],
              literal: ["false", "true", "FALSE", "TRUE", "nil", "YES", "NO", "NULL"],
              built_in: ["BOOL", "dispatch_once_t", "dispatch_queue_t", "dispatch_sync", "dispatch_async", "dispatch_once"]
            },
            illegal: "</",
            contains: [{
              className: "built_in",
              begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
            }, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, e2.C_NUMBER_MODE, e2.QUOTE_STRING_MODE, e2.APOS_STRING_MODE, {
              className: "string",
              variants: [{
                begin: '@"',
                end: '"',
                illegal: "\\n",
                contains: [e2.BACKSLASH_ESCAPE]
              }]
            }, {
              className: "meta",
              begin: /#\s*[a-z]+\b/,
              end: /$/,
              keywords: {
                keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include"
              },
              contains: [{ begin: /\\\n/, relevance: 0 }, e2.inherit(e2.QUOTE_STRING_MODE, {
                className: "string"
              }), {
                className: "string",
                begin: /<.*?>/,
                end: /$/,
                illegal: "\\n"
              }, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
            }, {
              className: "class",
              begin: "(" + t2.keyword.join("|") + ")\\b",
              end: /(\{|$)/,
              excludeEnd: true,
              keywords: t2,
              contains: [e2.UNDERSCORE_TITLE_MODE]
            }, {
              begin: "\\." + e2.UNDERSCORE_IDENT_RE,
              relevance: 0
            }]
          };
        },
        grmr_perl: (e2) => {
          const n2 = e2.regex, t2 = /[dualxmsipngr]{0,12}/, a2 = {
            $pattern: /[\w.]+/,
            keyword: "abs accept alarm and atan2 bind binmode bless break caller chdir chmod chomp chop chown chr chroot close closedir connect continue cos crypt dbmclose dbmopen defined delete die do dump each else elsif endgrent endhostent endnetent endprotoent endpwent endservent eof eval exec exists exit exp fcntl fileno flock for foreach fork format formline getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername getpgrp getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname getservbyport getservent getsockname getsockopt given glob gmtime goto grep gt hex if index int ioctl join keys kill last lc lcfirst length link listen local localtime log lstat lt ma map mkdir msgctl msgget msgrcv msgsnd my ne next no not oct open opendir or ord our pack package pipe pop pos print printf prototype push q|0 qq quotemeta qw qx rand read readdir readline readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir say scalar seek seekdir select semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat state study sub substr symlink syscall sysopen sysread sysseek system syswrite tell telldir tie tied time times tr truncate uc ucfirst umask undef unless unlink unpack unshift untie until use utime values vec wait waitpid wantarray warn when while write x|0 xor y|0"
          }, i2 = { className: "subst", begin: "[$@]\\{", end: "\\}", keywords: a2 }, r2 = {
            begin: /->\{/,
            end: /\}/
          }, s2 = {
            variants: [{ begin: /\$\d/ }, {
              begin: n2.concat(/[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/, "(?![A-Za-z])(?![@$%])")
            }, { begin: /[$%@][^\s\w{]/, relevance: 0 }]
          }, o2 = [e2.BACKSLASH_ESCAPE, i2, s2], l2 = [/!/, /\//, /\|/, /\?/, /'/, /"/, /#/], c2 = (e3, a3, i3 = "\\1") => {
            const r3 = "\\1" === i3 ? i3 : n2.concat(i3, a3);
            return n2.concat(n2.concat("(?:", e3, ")"), a3, /(?:\\.|[^\\\/])*?/, r3, /(?:\\.|[^\\\/])*?/, i3, t2);
          }, d2 = (e3, a3, i3) => n2.concat(n2.concat("(?:", e3, ")"), a3, /(?:\\.|[^\\\/])*?/, i3, t2), g2 = [s2, e2.HASH_COMMENT_MODE, e2.COMMENT(/^=\w/, /=cut/, {
            endsWithParent: true
          }), r2, { className: "string", contains: o2, variants: [{
            begin: "q[qwxr]?\\s*\\(",
            end: "\\)",
            relevance: 5
          }, {
            begin: "q[qwxr]?\\s*\\[",
            end: "\\]",
            relevance: 5
          }, { begin: "q[qwxr]?\\s*\\{", end: "\\}", relevance: 5 }, {
            begin: "q[qwxr]?\\s*\\|",
            end: "\\|",
            relevance: 5
          }, {
            begin: "q[qwxr]?\\s*<",
            end: ">",
            relevance: 5
          }, { begin: "qw\\s+q", end: "q", relevance: 5 }, {
            begin: "'",
            end: "'",
            contains: [e2.BACKSLASH_ESCAPE]
          }, { begin: '"', end: '"' }, {
            begin: "`",
            end: "`",
            contains: [e2.BACKSLASH_ESCAPE]
          }, { begin: /\{\w+\}/, relevance: 0 }, {
            begin: "-?\\w+\\s*=>",
            relevance: 0
          }] }, {
            className: "number",
            begin: "(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",
            relevance: 0
          }, {
            begin: "(\\/\\/|" + e2.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
            keywords: "split return print reverse grep",
            relevance: 0,
            contains: [e2.HASH_COMMENT_MODE, { className: "regexp", variants: [{
              begin: c2("s|tr|y", n2.either(...l2, { capture: true }))
            }, { begin: c2("s|tr|y", "\\(", "\\)") }, {
              begin: c2("s|tr|y", "\\[", "\\]")
            }, { begin: c2("s|tr|y", "\\{", "\\}") }], relevance: 2 }, {
              className: "regexp",
              variants: [{ begin: /(m|qr)\/\//, relevance: 0 }, {
                begin: d2("(?:m|qr)?", /\//, /\//)
              }, { begin: d2("m|qr", n2.either(...l2, {
                capture: true
              }), /\1/) }, { begin: d2("m|qr", /\(/, /\)/) }, { begin: d2("m|qr", /\[/, /\]/) }, {
                begin: d2("m|qr", /\{/, /\}/)
              }]
            }]
          }, {
            className: "function",
            beginKeywords: "sub",
            end: "(\\s*\\(.*?\\))?[;{]",
            excludeEnd: true,
            relevance: 5,
            contains: [e2.TITLE_MODE]
          }, {
            begin: "-\\w\\b",
            relevance: 0
          }, {
            begin: "^__DATA__$",
            end: "^__END__$",
            subLanguage: "mojolicious",
            contains: [{ begin: "^@@.*", end: "$", className: "comment" }]
          }];
          return i2.contains = g2, r2.contains = g2, {
            name: "Perl",
            aliases: ["pl", "pm"],
            keywords: a2,
            contains: g2
          };
        },
        grmr_php: (e2) => {
          const n2 = {
            className: "variable",
            begin: "\\$+[a-zA-Z_-ÿ][a-zA-Z0-9_-ÿ]*(?![A-Za-z0-9])(?![$])"
          }, t2 = {
            className: "meta",
            variants: [{ begin: /<\?php/, relevance: 10 }, { begin: /<\?[=]?/ }, {
              begin: /\?>/
            }]
          }, a2 = { className: "subst", variants: [{ begin: /\$\w+/ }, {
            begin: /\{\$/,
            end: /\}/
          }] }, i2 = e2.inherit(e2.APOS_STRING_MODE, {
            illegal: null
          }), r2 = e2.inherit(e2.QUOTE_STRING_MODE, {
            illegal: null,
            contains: e2.QUOTE_STRING_MODE.contains.concat(a2)
          }), s2 = e2.END_SAME_AS_BEGIN({
            begin: /<<<[ \t]*(\w+)\n/,
            end: /[ \t]*(\w+)\b/,
            contains: e2.QUOTE_STRING_MODE.contains.concat(a2)
          }), o2 = {
            className: "string",
            contains: [e2.BACKSLASH_ESCAPE, t2],
            variants: [e2.inherit(i2, {
              begin: "b'",
              end: "'"
            }), e2.inherit(r2, { begin: 'b"', end: '"' }), r2, i2, s2]
          }, l2 = { className: "number", variants: [{
            begin: "\\b0b[01]+(?:_[01]+)*\\b"
          }, { begin: "\\b0o[0-7]+(?:_[0-7]+)*\\b" }, {
            begin: "\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b"
          }, {
            begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:e[+-]?\\d+)?"
          }], relevance: 0 }, c2 = {
            keyword: "__CLASS__ __DIR__ __FILE__ __FUNCTION__ __LINE__ __METHOD__ __NAMESPACE__ __TRAIT__ die echo exit include include_once print require require_once array abstract and as binary bool boolean break callable case catch class clone const continue declare default do double else elseif empty enddeclare endfor endforeach endif endswitch endwhile enum eval extends final finally float for foreach from global goto if implements instanceof insteadof int integer interface isset iterable list match|0 mixed new object or private protected public real return string switch throw trait try unset use var void while xor yield",
            literal: "false null true",
            built_in: "Error|0 AppendIterator ArgumentCountError ArithmeticError ArrayIterator ArrayObject AssertionError BadFunctionCallException BadMethodCallException CachingIterator CallbackFilterIterator CompileError Countable DirectoryIterator DivisionByZeroError DomainException EmptyIterator ErrorException Exception FilesystemIterator FilterIterator GlobIterator InfiniteIterator InvalidArgumentException IteratorIterator LengthException LimitIterator LogicException MultipleIterator NoRewindIterator OutOfBoundsException OutOfRangeException OuterIterator OverflowException ParentIterator ParseError RangeException RecursiveArrayIterator RecursiveCachingIterator RecursiveCallbackFilterIterator RecursiveDirectoryIterator RecursiveFilterIterator RecursiveIterator RecursiveIteratorIterator RecursiveRegexIterator RecursiveTreeIterator RegexIterator RuntimeException SeekableIterator SplDoublyLinkedList SplFileInfo SplFileObject SplFixedArray SplHeap SplMaxHeap SplMinHeap SplObjectStorage SplObserver SplObserver SplPriorityQueue SplQueue SplStack SplSubject SplSubject SplTempFileObject TypeError UnderflowException UnexpectedValueException UnhandledMatchError ArrayAccess Closure Generator Iterator IteratorAggregate Serializable Stringable Throwable Traversable WeakReference WeakMap Directory __PHP_Incomplete_Class parent php_user_filter self static stdClass"
          };
          return {
            case_insensitive: true,
            keywords: c2,
            contains: [e2.HASH_COMMENT_MODE, e2.COMMENT("//", "$", {
              contains: [t2]
            }), e2.COMMENT("/\\*", "\\*/", {
              contains: [{ className: "doctag", begin: "@[A-Za-z]+" }]
            }), e2.COMMENT("__halt_compiler.+?;", false, {
              endsWithParent: true,
              keywords: "__halt_compiler"
            }), t2, { className: "keyword", begin: /\$this\b/ }, n2, {
              begin: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/
            }, {
              className: "function",
              relevance: 0,
              beginKeywords: "fn function",
              end: /[;{]/,
              excludeEnd: true,
              illegal: "[$%\\[]",
              contains: [{ beginKeywords: "use" }, e2.UNDERSCORE_TITLE_MODE, {
                begin: "=>",
                endsParent: true
              }, {
                className: "params",
                begin: "\\(",
                end: "\\)",
                excludeBegin: true,
                excludeEnd: true,
                keywords: c2,
                contains: ["self", n2, e2.C_BLOCK_COMMENT_MODE, o2, l2]
              }]
            }, { className: "class", variants: [{
              beginKeywords: "enum",
              illegal: /[($"]/
            }, {
              beginKeywords: "class interface trait",
              illegal: /[:($"]/
            }], relevance: 0, end: /\{/, excludeEnd: true, contains: [{
              beginKeywords: "extends implements"
            }, e2.UNDERSCORE_TITLE_MODE] }, {
              beginKeywords: "namespace",
              relevance: 0,
              end: ";",
              illegal: /[.']/,
              contains: [e2.UNDERSCORE_TITLE_MODE]
            }, {
              beginKeywords: "use",
              relevance: 0,
              end: ";",
              contains: [e2.UNDERSCORE_TITLE_MODE]
            }, o2, l2]
          };
        },
        grmr_php_template: (e2) => ({
          name: "PHP template",
          subLanguage: "xml",
          contains: [{
            begin: /<\?(php|=)?/,
            end: /\?>/,
            subLanguage: "php",
            contains: [{ begin: "/\\*", end: "\\*/", skip: true }, {
              begin: 'b"',
              end: '"',
              skip: true
            }, { begin: "b'", end: "'", skip: true }, e2.inherit(e2.APOS_STRING_MODE, {
              illegal: null,
              className: null,
              contains: null,
              skip: true
            }), e2.inherit(e2.QUOTE_STRING_MODE, {
              illegal: null,
              className: null,
              contains: null,
              skip: true
            })]
          }]
        }),
        grmr_plaintext: (e2) => ({
          name: "Plain text",
          aliases: ["text", "txt"],
          disableAutodetect: true
        }),
        grmr_python: (e2) => {
          const n2 = e2.regex, t2 = /[\p{XID_Start}_]\p{XID_Continue}*/u, a2 = {
            $pattern: /[A-Za-z]\w+|__\w+__/,
            keyword: ["and", "as", "assert", "async", "await", "break", "class", "continue", "def", "del", "elif", "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", "nonlocal|10", "not", "or", "pass", "raise", "return", "try", "while", "with", "yield"],
            built_in: ["__import__", "abs", "all", "any", "ascii", "bin", "bool", "breakpoint", "bytearray", "bytes", "callable", "chr", "classmethod", "compile", "complex", "delattr", "dict", "dir", "divmod", "enumerate", "eval", "exec", "filter", "float", "format", "frozenset", "getattr", "globals", "hasattr", "hash", "help", "hex", "id", "input", "int", "isinstance", "issubclass", "iter", "len", "list", "locals", "map", "max", "memoryview", "min", "next", "object", "oct", "open", "ord", "pow", "print", "property", "range", "repr", "reversed", "round", "set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super", "tuple", "type", "vars", "zip"],
            literal: ["__debug__", "Ellipsis", "False", "None", "NotImplemented", "True"],
            type: ["Any", "Callable", "Coroutine", "Dict", "List", "Literal", "Generic", "Optional", "Sequence", "Set", "Tuple", "Type", "Union"]
          }, i2 = { className: "meta", begin: /^(>>>|\.\.\.) / }, r2 = {
            className: "subst",
            begin: /\{/,
            end: /\}/,
            keywords: a2,
            illegal: /#/
          }, s2 = { begin: /\{\{/, relevance: 0 }, o2 = {
            className: "string",
            contains: [e2.BACKSLASH_ESCAPE],
            variants: [{
              begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
              end: /'''/,
              contains: [e2.BACKSLASH_ESCAPE, i2],
              relevance: 10
            }, {
              begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
              end: /"""/,
              contains: [e2.BACKSLASH_ESCAPE, i2],
              relevance: 10
            }, {
              begin: /([fF][rR]|[rR][fF]|[fF])'''/,
              end: /'''/,
              contains: [e2.BACKSLASH_ESCAPE, i2, s2, r2]
            }, {
              begin: /([fF][rR]|[rR][fF]|[fF])"""/,
              end: /"""/,
              contains: [e2.BACKSLASH_ESCAPE, i2, s2, r2]
            }, {
              begin: /([uU]|[rR])'/,
              end: /'/,
              relevance: 10
            }, { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 }, {
              begin: /([bB]|[bB][rR]|[rR][bB])'/,
              end: /'/
            }, {
              begin: /([bB]|[bB][rR]|[rR][bB])"/,
              end: /"/
            }, {
              begin: /([fF][rR]|[rR][fF]|[fF])'/,
              end: /'/,
              contains: [e2.BACKSLASH_ESCAPE, s2, r2]
            }, {
              begin: /([fF][rR]|[rR][fF]|[fF])"/,
              end: /"/,
              contains: [e2.BACKSLASH_ESCAPE, s2, r2]
            }, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE]
          }, l2 = "[0-9](_?[0-9])*", c2 = `(\\b(${l2}))?\\.(${l2})|\\b(${l2})\\.`, d2 = {
            className: "number",
            relevance: 0,
            variants: [{
              begin: `(\\b(${l2})|(${c2}))[eE][+-]?(${l2})[jJ]?\\b`
            }, { begin: `(${c2})[jJ]?` }, {
              begin: "\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?\\b"
            }, {
              begin: "\\b0[bB](_?[01])+[lL]?\\b"
            }, { begin: "\\b0[oO](_?[0-7])+[lL]?\\b" }, {
              begin: "\\b0[xX](_?[0-9a-fA-F])+[lL]?\\b"
            }, { begin: `\\b(${l2})[jJ]\\b` }]
          }, g2 = {
            className: "comment",
            begin: n2.lookahead(/# type:/),
            end: /$/,
            keywords: a2,
            contains: [{
              begin: /# type:/
            }, { begin: /#/, end: /\b\B/, endsWithParent: true }]
          }, u2 = {
            className: "params",
            variants: [{ className: "", begin: /\(\s*\)/, skip: true }, {
              begin: /\(/,
              end: /\)/,
              excludeBegin: true,
              excludeEnd: true,
              keywords: a2,
              contains: ["self", i2, d2, o2, e2.HASH_COMMENT_MODE]
            }]
          };
          return r2.contains = [o2, d2, i2], {
            name: "Python",
            aliases: ["py", "gyp", "ipython"],
            unicodeRegex: true,
            keywords: a2,
            illegal: /(<\/|->|\?)|=>/,
            contains: [i2, d2, { begin: /\bself\b/ }, {
              beginKeywords: "if",
              relevance: 0
            }, o2, g2, e2.HASH_COMMENT_MODE, { match: [/def/, /\s+/, t2], scope: {
              1: "keyword",
              3: "title.function"
            }, contains: [u2] }, {
              variants: [{
                match: [/class/, /\s+/, t2, /\s*/, /\(\s*/, t2, /\s*\)/]
              }, { match: [/class/, /\s+/, t2] }],
              scope: { 1: "keyword", 3: "title.class", 6: "title.class.inherited" }
            }, {
              className: "meta",
              begin: /^[\t ]*@/,
              end: /(?=#)|$/,
              contains: [d2, u2, o2]
            }]
          };
        },
        grmr_python_repl: (e2) => ({ aliases: ["pycon"], contains: [{ className: "meta", starts: {
          end: / |$/,
          starts: { end: "$", subLanguage: "python" }
        }, variants: [{
          begin: /^>>>(?=[ ]|$)/
        }, { begin: /^\.\.\.(?=[ ]|$)/ }] }] }),
        grmr_r: (e2) => {
          const n2 = e2.regex, t2 = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, a2 = n2.either(/0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/, /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/, /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/), i2 = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, r2 = n2.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/);
          return { name: "R", keywords: {
            $pattern: t2,
            keyword: "function if in break next repeat else for while",
            literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
            built_in: "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
          }, contains: [e2.COMMENT(/#'/, /$/, {
            contains: [{
              scope: "doctag",
              match: /@examples/,
              starts: {
                end: n2.lookahead(n2.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)),
                endsParent: true
              }
            }, { scope: "doctag", begin: "@param", end: /$/, contains: [{
              scope: "variable",
              variants: [{ match: t2 }, { match: /`(?:\\.|[^`\\])+`/ }],
              endsParent: true
            }] }, { scope: "doctag", match: /@[a-zA-Z]+/ }, { scope: "keyword", match: /\\[a-zA-Z]+/ }]
          }), e2.HASH_COMMENT_MODE, {
            scope: "string",
            contains: [e2.BACKSLASH_ESCAPE],
            variants: [e2.END_SAME_AS_BEGIN({
              begin: /[rR]"(-*)\(/,
              end: /\)(-*)"/
            }), e2.END_SAME_AS_BEGIN({
              begin: /[rR]"(-*)\{/,
              end: /\}(-*)"/
            }), e2.END_SAME_AS_BEGIN({
              begin: /[rR]"(-*)\[/,
              end: /\](-*)"/
            }), e2.END_SAME_AS_BEGIN({
              begin: /[rR]'(-*)\(/,
              end: /\)(-*)'/
            }), e2.END_SAME_AS_BEGIN({
              begin: /[rR]'(-*)\{/,
              end: /\}(-*)'/
            }), e2.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\[/, end: /\](-*)'/ }), {
              begin: '"',
              end: '"',
              relevance: 0
            }, { begin: "'", end: "'", relevance: 0 }]
          }, { relevance: 0, variants: [{ scope: {
            1: "operator",
            2: "number"
          }, match: [i2, a2] }, {
            scope: { 1: "operator", 2: "number" },
            match: [/%[^%]*%/, a2]
          }, { scope: { 1: "punctuation", 2: "number" }, match: [r2, a2] }, { scope: {
            2: "number"
          }, match: [/[^a-zA-Z0-9._]|^/, a2] }] }, {
            scope: { 3: "operator" },
            match: [t2, /\s+/, /<-/, /\s+/]
          }, { scope: "operator", relevance: 0, variants: [{ match: i2 }, {
            match: /%[^%]*%/
          }] }, { scope: "punctuation", relevance: 0, match: r2 }, {
            begin: "`",
            end: "`",
            contains: [{ begin: /\\./ }]
          }] };
        },
        grmr_ruby: (e2) => {
          const n2 = e2.regex, t2 = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", a2 = {
            keyword: "and then defined module in return redo if BEGIN retry end for self when next until do begin unless END rescue else break undef not super class case require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor __FILE__",
            built_in: "proc lambda",
            literal: "true false nil"
          }, i2 = {
            className: "doctag",
            begin: "@[A-Za-z]+"
          }, r2 = { begin: "#<", end: ">" }, s2 = [e2.COMMENT("#", "$", {
            contains: [i2]
          }), e2.COMMENT("^=begin", "^=end", {
            contains: [i2],
            relevance: 10
          }), e2.COMMENT("^__END__", "\\n$")], o2 = {
            className: "subst",
            begin: /#\{/,
            end: /\}/,
            keywords: a2
          }, l2 = { className: "string", contains: [e2.BACKSLASH_ESCAPE, o2], variants: [{
            begin: /'/,
            end: /'/
          }, { begin: /"/, end: /"/ }, { begin: /`/, end: /`/ }, {
            begin: /%[qQwWx]?\(/,
            end: /\)/
          }, { begin: /%[qQwWx]?\[/, end: /\]/ }, { begin: /%[qQwWx]?\{/, end: /\}/ }, {
            begin: /%[qQwWx]?</,
            end: />/
          }, { begin: /%[qQwWx]?\//, end: /\// }, {
            begin: /%[qQwWx]?%/,
            end: /%/
          }, { begin: /%[qQwWx]?-/, end: /-/ }, { begin: /%[qQwWx]?\|/, end: /\|/ }, {
            begin: /\B\?(\\\d{1,3})/
          }, { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ }, {
            begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/
          }, {
            begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/
          }, {
            begin: /\B\?\\(c|C-)[\x20-\x7e]/
          }, { begin: /\B\?\\?\S/ }, {
            begin: n2.concat(/<<[-~]?'?/, n2.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)),
            contains: [e2.END_SAME_AS_BEGIN({
              begin: /(\w+)/,
              end: /(\w+)/,
              contains: [e2.BACKSLASH_ESCAPE, o2]
            })]
          }] }, c2 = "[0-9](_?[0-9])*", d2 = {
            className: "number",
            relevance: 0,
            variants: [{
              begin: `\\b([1-9](_?[0-9])*|0)(\\.(${c2}))?([eE][+-]?(${c2})|r)?i?\\b`
            }, {
              begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b"
            }, {
              begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b"
            }, { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" }, {
              begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b"
            }, {
              begin: "\\b0(_?[0-7])+r?i?\\b"
            }]
          }, g2 = {
            className: "params",
            begin: "\\(",
            end: "\\)",
            endsParent: true,
            keywords: a2
          }, u2 = [l2, {
            className: "class",
            beginKeywords: "class module",
            end: "$|;",
            illegal: /=/,
            contains: [e2.inherit(e2.TITLE_MODE, {
              begin: "[A-Za-z_]\\w*(::\\w+)*(\\?|!)?"
            }), { begin: "<\\s*", contains: [{
              begin: "(" + e2.IDENT_RE + "::)?" + e2.IDENT_RE,
              relevance: 0
            }] }].concat(s2)
          }, {
            className: "function",
            begin: n2.concat(/def\s+/, n2.lookahead(t2 + "\\s*(\\(|;|$)")),
            relevance: 0,
            keywords: "def",
            end: "$|;",
            contains: [e2.inherit(e2.TITLE_MODE, {
              begin: t2
            }), g2].concat(s2)
          }, { begin: e2.IDENT_RE + "::" }, {
            className: "symbol",
            begin: e2.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
            relevance: 0
          }, {
            className: "symbol",
            begin: ":(?!\\s)",
            contains: [l2, { begin: t2 }],
            relevance: 0
          }, d2, {
            className: "variable",
            begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
          }, {
            className: "params",
            begin: /\|/,
            end: /\|/,
            relevance: 0,
            keywords: a2
          }, {
            begin: "(" + e2.RE_STARTERS_RE + "|unless)\\s*",
            keywords: "unless",
            contains: [{
              className: "regexp",
              contains: [e2.BACKSLASH_ESCAPE, o2],
              illegal: /\n/,
              variants: [{
                begin: "/",
                end: "/[a-z]*"
              }, { begin: /%r\{/, end: /\}[a-z]*/ }, {
                begin: "%r\\(",
                end: "\\)[a-z]*"
              }, { begin: "%r!", end: "![a-z]*" }, { begin: "%r\\[", end: "\\][a-z]*" }]
            }].concat(r2, s2),
            relevance: 0
          }].concat(r2, s2);
          o2.contains = u2, g2.contains = u2;
          const b2 = [{
            begin: /^\s*=>/,
            starts: { end: "$", contains: u2 }
          }, {
            className: "meta",
            begin: "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+>|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",
            starts: { end: "$", contains: u2 }
          }];
          return s2.unshift(r2), {
            name: "Ruby",
            aliases: ["rb", "gemspec", "podspec", "thor", "irb"],
            keywords: a2,
            illegal: /\/\*/,
            contains: [e2.SHEBANG({ binary: "ruby" })].concat(b2).concat(s2).concat(u2)
          };
        },
        grmr_rust: (e2) => {
          const n2 = e2.regex, t2 = {
            className: "title.function.invoke",
            relevance: 0,
            begin: n2.concat(/\b/, /(?!let\b)/, e2.IDENT_RE, n2.lookahead(/\s*\(/))
          }, a2 = "([ui](8|16|32|64|128|size)|f(32|64))?", i2 = ["drop ", "Copy", "Send", "Sized", "Sync", "Drop", "Fn", "FnMut", "FnOnce", "ToOwned", "Clone", "Debug", "PartialEq", "PartialOrd", "Eq", "Ord", "AsRef", "AsMut", "Into", "From", "Default", "Iterator", "Extend", "IntoIterator", "DoubleEndedIterator", "ExactSizeIterator", "SliceConcatExt", "ToString", "assert!", "assert_eq!", "bitflags!", "bytes!", "cfg!", "col!", "concat!", "concat_idents!", "debug_assert!", "debug_assert_eq!", "env!", "panic!", "file!", "format!", "format_args!", "include_bin!", "include_str!", "line!", "local_data_key!", "module_path!", "option_env!", "print!", "println!", "select!", "stringify!", "try!", "unimplemented!", "unreachable!", "vec!", "write!", "writeln!", "macro_rules!", "assert_ne!", "debug_assert_ne!"];
          return {
            name: "Rust",
            aliases: ["rs"],
            keywords: {
              $pattern: e2.IDENT_RE + "!?",
              type: ["i8", "i16", "i32", "i64", "i128", "isize", "u8", "u16", "u32", "u64", "u128", "usize", "f32", "f64", "str", "char", "bool", "Box", "Option", "Result", "String", "Vec"],
              keyword: ["abstract", "as", "async", "await", "become", "box", "break", "const", "continue", "crate", "do", "dyn", "else", "enum", "extern", "false", "final", "fn", "for", "if", "impl", "in", "let", "loop", "macro", "match", "mod", "move", "mut", "override", "priv", "pub", "ref", "return", "self", "Self", "static", "struct", "super", "trait", "true", "try", "type", "typeof", "unsafe", "unsized", "use", "virtual", "where", "while", "yield"],
              literal: ["true", "false", "Some", "None", "Ok", "Err"],
              built_in: i2
            },
            illegal: "</",
            contains: [e2.C_LINE_COMMENT_MODE, e2.COMMENT("/\\*", "\\*/", {
              contains: ["self"]
            }), e2.inherit(e2.QUOTE_STRING_MODE, { begin: /b?"/, illegal: null }), {
              className: "string",
              variants: [{ begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ }, {
                begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/
              }]
            }, {
              className: "symbol",
              begin: /'[a-zA-Z_][a-zA-Z0-9_]*/
            }, { className: "number", variants: [{
              begin: "\\b0b([01_]+)" + a2
            }, { begin: "\\b0o([0-7_]+)" + a2 }, {
              begin: "\\b0x([A-Fa-f0-9_]+)" + a2
            }, {
              begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + a2
            }], relevance: 0 }, {
              begin: [/fn/, /\s+/, e2.UNDERSCORE_IDENT_RE],
              className: {
                1: "keyword",
                3: "title.function"
              }
            }, { className: "meta", begin: "#!?\\[", end: "\\]", contains: [{
              className: "string",
              begin: /"/,
              end: /"/
            }] }, {
              begin: [/let/, /\s+/, /(?:mut\s+)?/, e2.UNDERSCORE_IDENT_RE],
              className: {
                1: "keyword",
                3: "keyword",
                4: "variable"
              }
            }, {
              begin: [/for/, /\s+/, e2.UNDERSCORE_IDENT_RE, /\s+/, /in/],
              className: {
                1: "keyword",
                3: "variable",
                5: "keyword"
              }
            }, {
              begin: [/type/, /\s+/, e2.UNDERSCORE_IDENT_RE],
              className: { 1: "keyword", 3: "title.class" }
            }, {
              begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, e2.UNDERSCORE_IDENT_RE],
              className: { 1: "keyword", 3: "title.class" }
            }, { begin: e2.IDENT_RE + "::", keywords: {
              keyword: "Self",
              built_in: i2
            } }, { className: "punctuation", begin: "->" }, t2]
          };
        },
        grmr_scss: (e2) => {
          const n2 = te(e2), t2 = se, a2 = re, i2 = "@[a-z-]+", r2 = {
            className: "variable",
            begin: "(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b"
          };
          return {
            name: "SCSS",
            case_insensitive: true,
            illegal: "[=/|']",
            contains: [e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, n2.CSS_NUMBER_MODE, {
              className: "selector-id",
              begin: "#[A-Za-z0-9_-]+",
              relevance: 0
            }, {
              className: "selector-class",
              begin: "\\.[A-Za-z0-9_-]+",
              relevance: 0
            }, n2.ATTRIBUTE_SELECTOR_MODE, {
              className: "selector-tag",
              begin: "\\b(" + ae.join("|") + ")\\b",
              relevance: 0
            }, {
              className: "selector-pseudo",
              begin: ":(" + a2.join("|") + ")"
            }, {
              className: "selector-pseudo",
              begin: ":(:)?(" + t2.join("|") + ")"
            }, r2, {
              begin: /\(/,
              end: /\)/,
              contains: [n2.CSS_NUMBER_MODE]
            }, n2.CSS_VARIABLE, {
              className: "attribute",
              begin: "\\b(" + oe.join("|") + ")\\b"
            }, {
              begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"
            }, {
              begin: /:/,
              end: /[;}{]/,
              contains: [n2.BLOCK_COMMENT, r2, n2.HEXCOLOR, n2.CSS_NUMBER_MODE, e2.QUOTE_STRING_MODE, e2.APOS_STRING_MODE, n2.IMPORTANT]
            }, { begin: "@(page|font-face)", keywords: { $pattern: i2, keyword: "@page @font-face" } }, {
              begin: "@",
              end: "[{;]",
              returnBegin: true,
              keywords: {
                $pattern: /[a-z-]+/,
                keyword: "and or not only",
                attribute: ie.join(" ")
              },
              contains: [{
                begin: i2,
                className: "keyword"
              }, {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              }, r2, e2.QUOTE_STRING_MODE, e2.APOS_STRING_MODE, n2.HEXCOLOR, n2.CSS_NUMBER_MODE]
            }, n2.FUNCTION_DISPATCH]
          };
        },
        grmr_shell: (e2) => ({
          name: "Shell Session",
          aliases: ["console", "shellsession"],
          contains: [{
            className: "meta",
            begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
            starts: {
              end: /[^\\](?=\s*$)/,
              subLanguage: "bash"
            }
          }]
        }),
        grmr_sql: (e2) => {
          const n2 = e2.regex, t2 = e2.COMMENT("--", "$"), a2 = ["true", "false", "unknown"], i2 = ["bigint", "binary", "blob", "boolean", "char", "character", "clob", "date", "dec", "decfloat", "decimal", "float", "int", "integer", "interval", "nchar", "nclob", "national", "numeric", "real", "row", "smallint", "time", "timestamp", "varchar", "varying", "varbinary"], r2 = ["abs", "acos", "array_agg", "asin", "atan", "avg", "cast", "ceil", "ceiling", "coalesce", "corr", "cos", "cosh", "count", "covar_pop", "covar_samp", "cume_dist", "dense_rank", "deref", "element", "exp", "extract", "first_value", "floor", "json_array", "json_arrayagg", "json_exists", "json_object", "json_objectagg", "json_query", "json_table", "json_table_primitive", "json_value", "lag", "last_value", "lead", "listagg", "ln", "log", "log10", "lower", "max", "min", "mod", "nth_value", "ntile", "nullif", "percent_rank", "percentile_cont", "percentile_disc", "position", "position_regex", "power", "rank", "regr_avgx", "regr_avgy", "regr_count", "regr_intercept", "regr_r2", "regr_slope", "regr_sxx", "regr_sxy", "regr_syy", "row_number", "sin", "sinh", "sqrt", "stddev_pop", "stddev_samp", "substring", "substring_regex", "sum", "tan", "tanh", "translate", "translate_regex", "treat", "trim", "trim_array", "unnest", "upper", "value_of", "var_pop", "var_samp", "width_bucket"], s2 = ["create table", "insert into", "primary key", "foreign key", "not null", "alter table", "add constraint", "grouping sets", "on overflow", "character set", "respect nulls", "ignore nulls", "nulls first", "nulls last", "depth first", "breadth first"], o2 = r2, l2 = ["abs", "acos", "all", "allocate", "alter", "and", "any", "are", "array", "array_agg", "array_max_cardinality", "as", "asensitive", "asin", "asymmetric", "at", "atan", "atomic", "authorization", "avg", "begin", "begin_frame", "begin_partition", "between", "bigint", "binary", "blob", "boolean", "both", "by", "call", "called", "cardinality", "cascaded", "case", "cast", "ceil", "ceiling", "char", "char_length", "character", "character_length", "check", "classifier", "clob", "close", "coalesce", "collate", "collect", "column", "commit", "condition", "connect", "constraint", "contains", "convert", "copy", "corr", "corresponding", "cos", "cosh", "count", "covar_pop", "covar_samp", "create", "cross", "cube", "cume_dist", "current", "current_catalog", "current_date", "current_default_transform_group", "current_path", "current_role", "current_row", "current_schema", "current_time", "current_timestamp", "current_path", "current_role", "current_transform_group_for_type", "current_user", "cursor", "cycle", "date", "day", "deallocate", "dec", "decimal", "decfloat", "declare", "default", "define", "delete", "dense_rank", "deref", "describe", "deterministic", "disconnect", "distinct", "double", "drop", "dynamic", "each", "element", "else", "empty", "end", "end_frame", "end_partition", "end-exec", "equals", "escape", "every", "except", "exec", "execute", "exists", "exp", "external", "extract", "false", "fetch", "filter", "first_value", "float", "floor", "for", "foreign", "frame_row", "free", "from", "full", "function", "fusion", "get", "global", "grant", "group", "grouping", "groups", "having", "hold", "hour", "identity", "in", "indicator", "initial", "inner", "inout", "insensitive", "insert", "int", "integer", "intersect", "intersection", "interval", "into", "is", "join", "json_array", "json_arrayagg", "json_exists", "json_object", "json_objectagg", "json_query", "json_table", "json_table_primitive", "json_value", "lag", "language", "large", "last_value", "lateral", "lead", "leading", "left", "like", "like_regex", "listagg", "ln", "local", "localtime", "localtimestamp", "log", "log10", "lower", "match", "match_number", "match_recognize", "matches", "max", "member", "merge", "method", "min", "minute", "mod", "modifies", "module", "month", "multiset", "national", "natural", "nchar", "nclob", "new", "no", "none", "normalize", "not", "nth_value", "ntile", "null", "nullif", "numeric", "octet_length", "occurrences_regex", "of", "offset", "old", "omit", "on", "one", "only", "open", "or", "order", "out", "outer", "over", "overlaps", "overlay", "parameter", "partition", "pattern", "per", "percent", "percent_rank", "percentile_cont", "percentile_disc", "period", "portion", "position", "position_regex", "power", "precedes", "precision", "prepare", "primary", "procedure", "ptf", "range", "rank", "reads", "real", "recursive", "ref", "references", "referencing", "regr_avgx", "regr_avgy", "regr_count", "regr_intercept", "regr_r2", "regr_slope", "regr_sxx", "regr_sxy", "regr_syy", "release", "result", "return", "returns", "revoke", "right", "rollback", "rollup", "row", "row_number", "rows", "running", "savepoint", "scope", "scroll", "search", "second", "seek", "select", "sensitive", "session_user", "set", "show", "similar", "sin", "sinh", "skip", "smallint", "some", "specific", "specifictype", "sql", "sqlexception", "sqlstate", "sqlwarning", "sqrt", "start", "static", "stddev_pop", "stddev_samp", "submultiset", "subset", "substring", "substring_regex", "succeeds", "sum", "symmetric", "system", "system_time", "system_user", "table", "tablesample", "tan", "tanh", "then", "time", "timestamp", "timezone_hour", "timezone_minute", "to", "trailing", "translate", "translate_regex", "translation", "treat", "trigger", "trim", "trim_array", "true", "truncate", "uescape", "union", "unique", "unknown", "unnest", "update", "upper", "user", "using", "value", "values", "value_of", "var_pop", "var_samp", "varbinary", "varchar", "varying", "versioning", "when", "whenever", "where", "width_bucket", "window", "with", "within", "without", "year", "add", "asc", "collation", "desc", "final", "first", "last", "view"].filter((e3) => !r2.includes(e3)), c2 = {
            begin: n2.concat(/\b/, n2.either(...o2), /\s*\(/),
            relevance: 0,
            keywords: { built_in: o2 }
          };
          return { name: "SQL", case_insensitive: true, illegal: /[{}]|<\//, keywords: {
            $pattern: /\b[\w\.]+/,
            keyword: ((e3, { exceptions: n3, when: t3 } = {}) => {
              const a3 = t3;
              return n3 = n3 || [], e3.map((e4) => e4.match(/\|\d+$/) || n3.includes(e4) ? e4 : a3(e4) ? e4 + "|0" : e4);
            })(l2, { when: (e3) => e3.length < 3 }),
            literal: a2,
            type: i2,
            built_in: ["current_catalog", "current_date", "current_default_transform_group", "current_path", "current_role", "current_schema", "current_transform_group_for_type", "current_user", "session_user", "system_time", "system_user", "current_time", "localtime", "current_timestamp", "localtimestamp"]
          }, contains: [{ begin: n2.either(...s2), relevance: 0, keywords: {
            $pattern: /[\w\.]+/,
            keyword: l2.concat(s2),
            literal: a2,
            type: i2
          } }, {
            className: "type",
            begin: n2.either("double precision", "large object", "with timezone", "without timezone")
          }, c2, { className: "variable", begin: /@[a-z0-9]+/ }, { className: "string", variants: [{
            begin: /'/,
            end: /'/,
            contains: [{ begin: /''/ }]
          }] }, { begin: /"/, end: /"/, contains: [{
            begin: /""/
          }] }, e2.C_NUMBER_MODE, e2.C_BLOCK_COMMENT_MODE, t2, {
            className: "operator",
            begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
            relevance: 0
          }] };
        },
        grmr_swift: (e2) => {
          const n2 = { match: /\s+/, relevance: 0 }, t2 = e2.COMMENT("/\\*", "\\*/", {
            contains: ["self"]
          }), a2 = [e2.C_LINE_COMMENT_MODE, t2], i2 = {
            match: [/\./, p(...ve, ...Oe)],
            className: { 2: "keyword" }
          }, r2 = {
            match: m(/\./, p(...Me)),
            relevance: 0
          }, s2 = Me.filter((e3) => "string" == typeof e3).concat(["_|0"]), o2 = { variants: [{
            className: "keyword",
            match: p(...Me.filter((e3) => "string" != typeof e3).concat(xe).map(we), ...Oe)
          }] }, l2 = {
            $pattern: p(/\b\w+/, /#\w+/),
            keyword: s2.concat(Ae),
            literal: ke
          }, c2 = [i2, r2, o2], d2 = [{
            match: m(/\./, p(...Ce)),
            relevance: 0
          }, {
            className: "built_in",
            match: m(/\b/, p(...Ce), /(?=\()/)
          }], u2 = { match: /->/, relevance: 0 }, b2 = [u2, {
            className: "operator",
            relevance: 0,
            variants: [{ match: De }, { match: `\\.(\\.|${Re})+` }]
          }], _2 = "([0-9a-fA-F]_*)+", h2 = { className: "number", relevance: 0, variants: [{
            match: "\\b(([0-9]_*)+)(\\.(([0-9]_*)+))?([eE][+-]?(([0-9]_*)+))?\\b"
          }, {
            match: `\\b0x(${_2})(\\.(${_2}))?([pP][+-]?(([0-9]_*)+))?\\b`
          }, {
            match: /\b0o([0-7]_*)+\b/
          }, { match: /\b0b([01]_*)+\b/ }] }, f2 = (e3 = "") => ({
            className: "subst",
            variants: [{ match: m(/\\/, e3, /[0\\tnr"']/) }, {
              match: m(/\\/, e3, /u\{[0-9a-fA-F]{1,8}\}/)
            }]
          }), E2 = (e3 = "") => ({
            className: "subst",
            match: m(/\\/, e3, /[\t ]*(?:[\r\n]|\r\n)/)
          }), y2 = (e3 = "") => ({
            className: "subst",
            label: "interpol",
            begin: m(/\\/, e3, /\(/),
            end: /\)/
          }), N2 = (e3 = "") => ({
            begin: m(e3, /"""/),
            end: m(/"""/, e3),
            contains: [f2(e3), E2(e3), y2(e3)]
          }), w2 = (e3 = "") => ({
            begin: m(e3, /"/),
            end: m(/"/, e3),
            contains: [f2(e3), y2(e3)]
          }), v2 = {
            className: "string",
            variants: [N2(), N2("#"), N2("##"), N2("###"), w2(), w2("#"), w2("##"), w2("###")]
          }, O2 = {
            match: m(/`/, Be, /`/)
          }, x2 = [O2, { className: "variable", match: /\$\d+/ }, {
            className: "variable",
            match: `\\$${Le}+`
          }], M2 = [{
            match: /(@|#)available/,
            className: "keyword",
            starts: { contains: [{
              begin: /\(/,
              end: /\)/,
              keywords: ze,
              contains: [...b2, h2, v2]
            }] }
          }, { className: "keyword", match: m(/@/, p(...Fe)) }, {
            className: "meta",
            match: m(/@/, Be)
          }], k2 = { match: g(/\b[A-Z]/), relevance: 0, contains: [{
            className: "type",
            match: m(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Le, "+")
          }, { className: "type", match: $e, relevance: 0 }, { match: /[?!]+/, relevance: 0 }, {
            match: /\.\.\./,
            relevance: 0
          }, { match: m(/\s+&\s+/, g($e)), relevance: 0 }] }, S2 = {
            begin: /</,
            end: />/,
            keywords: l2,
            contains: [...a2, ...c2, ...M2, u2, k2]
          };
          k2.contains.push(S2);
          const A2 = { begin: /\(/, end: /\)/, relevance: 0, keywords: l2, contains: ["self", {
            match: m(Be, /\s*:/),
            keywords: "_|0",
            relevance: 0
          }, ...a2, ...c2, ...d2, ...b2, h2, v2, ...x2, ...M2, k2] }, C2 = {
            begin: /</,
            end: />/,
            contains: [...a2, k2]
          }, T2 = { begin: /\(/, end: /\)/, keywords: l2, contains: [{
            begin: p(g(m(Be, /\s*:/)), g(m(Be, /\s+/, Be, /\s*:/))),
            end: /:/,
            relevance: 0,
            contains: [{ className: "keyword", match: /\b_\b/ }, { className: "params", match: Be }]
          }, ...a2, ...c2, ...b2, h2, v2, ...M2, k2, A2], endsParent: true, illegal: /["']/ }, R2 = {
            match: [/func/, /\s+/, p(O2.match, Be, De)],
            className: {
              1: "keyword",
              3: "title.function"
            },
            contains: [C2, T2, n2],
            illegal: [/\[/, /%/]
          }, D2 = {
            match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
            className: { 1: "keyword" },
            contains: [C2, T2, n2],
            illegal: /\[|%/
          }, I2 = { match: [/operator/, /\s+/, De], className: {
            1: "keyword",
            3: "title"
          } }, L2 = { begin: [/precedencegroup/, /\s+/, $e], className: {
            1: "keyword",
            3: "title"
          }, contains: [k2], keywords: [...Se, ...ke], end: /}/ };
          for (const e3 of v2.variants) {
            const n3 = e3.contains.find((e4) => "interpol" === e4.label);
            n3.keywords = l2;
            const t3 = [...c2, ...d2, ...b2, h2, v2, ...x2];
            n3.contains = [...t3, {
              begin: /\(/,
              end: /\)/,
              contains: ["self", ...t3]
            }];
          }
          return {
            name: "Swift",
            keywords: l2,
            contains: [...a2, R2, D2, {
              beginKeywords: "struct protocol class extension enum actor",
              end: "\\{",
              excludeEnd: true,
              keywords: l2,
              contains: [e2.inherit(e2.TITLE_MODE, {
                className: "title.class",
                begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
              }), ...c2]
            }, I2, L2, {
              beginKeywords: "import",
              end: /$/,
              contains: [...a2],
              relevance: 0
            }, ...c2, ...d2, ...b2, h2, v2, ...x2, ...M2, k2, A2]
          };
        },
        grmr_typescript: (e2) => {
          const n2 = Ne(e2), t2 = ["any", "void", "number", "boolean", "string", "object", "never", "enum"], a2 = {
            beginKeywords: "namespace",
            end: /\{/,
            excludeEnd: true,
            contains: [n2.exports.CLASS_REFERENCE]
          }, i2 = {
            beginKeywords: "interface",
            end: /\{/,
            excludeEnd: true,
            keywords: { keyword: "interface extends", built_in: t2 },
            contains: [n2.exports.CLASS_REFERENCE]
          }, r2 = {
            $pattern: be,
            keyword: me.concat(["type", "namespace", "typedef", "interface", "public", "private", "protected", "implements", "declare", "abstract", "readonly"]),
            literal: pe,
            built_in: ye.concat(t2),
            "variable.language": Ee
          }, s2 = {
            className: "meta",
            begin: "@[A-Za-z$_][0-9A-Za-z$_]*"
          }, o2 = (e3, n3, t3) => {
            const a3 = e3.contains.findIndex((e4) => e4.label === n3);
            if (-1 === a3)
              throw Error("can not find mode to replace");
            e3.contains.splice(a3, 1, t3);
          };
          return Object.assign(n2.keywords, r2), n2.exports.PARAMS_CONTAINS.push(s2), n2.contains = n2.contains.concat([s2, a2, i2]), o2(n2, "shebang", e2.SHEBANG()), o2(n2, "use_strict", {
            className: "meta",
            relevance: 10,
            begin: /^\s*['"]use strict['"]/
          }), n2.contains.find((e3) => "func.def" === e3.label).relevance = 0, Object.assign(n2, {
            name: "TypeScript",
            aliases: ["ts", "tsx"]
          }), n2;
        },
        grmr_vbnet: (e2) => {
          const n2 = e2.regex, t2 = /\d{1,2}\/\d{1,2}\/\d{4}/, a2 = /\d{4}-\d{1,2}-\d{1,2}/, i2 = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, r2 = /\d{1,2}(:\d{1,2}){1,2}/, s2 = {
            className: "literal",
            variants: [{ begin: n2.concat(/# */, n2.either(a2, t2), / *#/) }, {
              begin: n2.concat(/# */, r2, / *#/)
            }, { begin: n2.concat(/# */, i2, / *#/) }, {
              begin: n2.concat(/# */, n2.either(a2, t2), / +/, n2.either(i2, r2), / *#/)
            }]
          }, o2 = e2.COMMENT(/'''/, /$/, {
            contains: [{ className: "doctag", begin: /<\/?/, end: />/ }]
          }), l2 = e2.COMMENT(null, /$/, { variants: [{ begin: /'/ }, { begin: /([\t ]|^)REM(?=\s)/ }] });
          return {
            name: "Visual Basic .NET",
            aliases: ["vb"],
            case_insensitive: true,
            classNameAliases: { label: "symbol" },
            keywords: {
              keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
              built_in: "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort",
              type: "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort",
              literal: "true false nothing"
            },
            illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
            contains: [{
              className: "string",
              begin: /"(""|[^/n])"C\b/
            }, {
              className: "string",
              begin: /"/,
              end: /"/,
              illegal: /\n/,
              contains: [{ begin: /""/ }]
            }, s2, {
              className: "number",
              relevance: 0,
              variants: [{
                begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
              }, { begin: /\b\d[\d_]*((U?[SIL])|[%&])?/ }, { begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/ }, {
                begin: /&O[0-7_]+((U?[SIL])|[%&])?/
              }, { begin: /&B[01_]+((U?[SIL])|[%&])?/ }]
            }, {
              className: "label",
              begin: /^\w+:/
            }, o2, l2, {
              className: "meta",
              begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
              end: /$/,
              keywords: {
                keyword: "const disable else elseif enable end externalsource if region then"
              },
              contains: [l2]
            }]
          };
        },
        grmr_yaml: (e2) => {
          const n2 = "true false yes no null", t2 = "[\\w#;/?:@&=+$,.~*'()[\\]]+", a2 = {
            className: "string",
            relevance: 0,
            variants: [{ begin: /'/, end: /'/ }, {
              begin: /"/,
              end: /"/
            }, { begin: /\S+/ }],
            contains: [e2.BACKSLASH_ESCAPE, {
              className: "template-variable",
              variants: [{ begin: /\{\{/, end: /\}\}/ }, { begin: /%\{/, end: /\}/ }]
            }]
          }, i2 = e2.inherit(a2, {
            variants: [{ begin: /'/, end: /'/ }, { begin: /"/, end: /"/ }, { begin: /[^\s,{}[\]]+/ }]
          }), r2 = {
            end: ",",
            endsWithParent: true,
            excludeEnd: true,
            keywords: n2,
            relevance: 0
          }, s2 = {
            begin: /\{/,
            end: /\}/,
            contains: [r2],
            illegal: "\\n",
            relevance: 0
          }, o2 = {
            begin: "\\[",
            end: "\\]",
            contains: [r2],
            illegal: "\\n",
            relevance: 0
          }, l2 = [{ className: "attr", variants: [{
            begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)"
          }, { begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)' }, {
            begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)"
          }] }, {
            className: "meta",
            begin: "^---\\s*$",
            relevance: 10
          }, {
            className: "string",
            begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
          }, {
            begin: "<%[%=-]?",
            end: "[%-]?%>",
            subLanguage: "ruby",
            excludeBegin: true,
            excludeEnd: true,
            relevance: 0
          }, { className: "type", begin: "!\\w+!" + t2 }, {
            className: "type",
            begin: "!<" + t2 + ">"
          }, { className: "type", begin: "!" + t2 }, {
            className: "type",
            begin: "!!" + t2
          }, { className: "meta", begin: "&" + e2.UNDERSCORE_IDENT_RE + "$" }, {
            className: "meta",
            begin: "\\*" + e2.UNDERSCORE_IDENT_RE + "$"
          }, {
            className: "bullet",
            begin: "-(?=[ ]|$)",
            relevance: 0
          }, e2.HASH_COMMENT_MODE, { beginKeywords: n2, keywords: { literal: n2 } }, {
            className: "number",
            begin: "\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b"
          }, { className: "number", begin: e2.C_NUMBER_RE + "\\b", relevance: 0 }, s2, o2, a2], c2 = [...l2];
          return c2.pop(), c2.push(i2), r2.contains = c2, {
            name: "YAML",
            case_insensitive: true,
            aliases: ["yml"],
            contains: l2
          };
        }
      });
      const je = ne;
      for (const e2 of Object.keys(Ue)) {
        const n2 = e2.replace("grmr_", "").replace("_", "-");
        je.registerLanguage(n2, Ue[e2]);
      }
      return je;
    }();
    "object" == typeof exports && "undefined" != typeof module && (module.exports = hljs);
  }
});
export default require_highlight_min();
/*! Bundled license information:

mavon-editor/dist/highlightjs/highlight.min.js:
  (*!
    Highlight.js v11.3.1 (git: 2a972d8658)
    (c) 2006-2021 Ivan Sagalaev and other contributors
    License: BSD-3-Clause
   *)
*/
//# sourceMappingURL=mavon-editor_dist_highlightjs_highlight__min.js.map
