"use strict";
const convert = (
  /**
   * @type {(
   *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * Generate an assertion from a check.
   * @param {Test} [test]
   * When nullish, checks if `node` is a `Node`.
   * When `string`, works like passing `function (node) {return node.type === test}`.
   * When `function` checks if function passed the node is true.
   * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
   * When `array`, checks any one of the subtests pass.
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return ok;
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length) {
    checks[index] = convert(tests[index]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all);
  function all(node) {
    let key;
    for (key in check) {
      if (node[key] !== check[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node) {
    return node && node.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(...parameters) {
    return Boolean(check.call(this, ...parameters));
  }
}
function ok() {
  return true;
}
function color(d) {
  return d;
}
const CONTINUE = true;
const SKIP = "skip";
const EXIT = false;
const visitParents = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types').BuildVisitor<Tree>, reverse?: boolean) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {import('./complex-types').Visitor<Node>} visitor
   * @param {boolean} [reverse]
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    const is = convert(test);
    const step = reverse ? -1 : 1;
    factory(tree, null, [])();
    function factory(node, index, parents) {
      const value = typeof node === "object" && node !== null ? node : {};
      let name;
      if (typeof value.type === "string") {
        name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
        Object.defineProperty(visit2, "name", {
          value: "node (" + color(value.type + (name ? "<" + name + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = [];
        let subresult;
        let offset;
        let grandparents;
        if (!test || is(node, index, parents[parents.length - 1] || null)) {
          result = toResult(visitor(node, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if (node.children && result[0] !== SKIP) {
          offset = (reverse ? node.children.length : -1) + step;
          grandparents = parents.concat(node);
          while (offset > -1 && offset < node.children.length) {
            subresult = factory(node.children[offset], offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
        return result;
      }
    }
  }
);
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}
const visit = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types').BuildVisitor<Tree>, reverse?: boolean) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {import('./complex-types').Visitor} visitor
   * @param {boolean} [reverse]
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node, parents) {
      const parent = parents[parents.length - 1];
      return visitor(
        node,
        parent ? parent.children.indexOf(node) : null,
        parent
      );
    }
  }
);
const find = /[\t ]*(?:\r?\n|\r)/g;
function remarkBreaks() {
  return (tree) => {
    visit(tree, "text", (node, index, parent) => {
      const result = [];
      let start = 0;
      find.lastIndex = 0;
      let match = find.exec(node.value);
      while (match) {
        const position = match.index;
        if (start !== position) {
          result.push({ type: "text", value: node.value.slice(start, position) });
        }
        result.push({ type: "break" });
        start = position + match[0].length;
        match = find.exec(node.value);
      }
      if (result.length > 0 && parent && typeof index === "number") {
        if (start < node.value.length) {
          result.push({ type: "text", value: node.value.slice(start) });
        }
        parent.children.splice(index, 1, ...result);
        return index + result.length;
      }
    });
  };
}
function breaks() {
  return {
    remark: (processor) => processor.use(remarkBreaks)
  };
}
module.exports = breaks;
