import { defineComponent, ref, watch, onMounted, openBlock, createElementBlock, computed, nextTick, onUnmounted } from "vue";
import { Editor, getProcessor } from "bytemd";
const _sfc_main$1 = defineComponent({
  props: {
    value: String,
    plugins: Array,
    sanitize: Function,
    remarkRehype: Object,
    mode: String,
    previewDebounce: Number,
    placeholder: String,
    editorConfig: Object,
    locale: Object,
    uploadImages: Function
  },
  emits: ["change"],
  setup(props, { emit }) {
    const el = ref(null);
    const editorRef = ref(null);
    watch(
      () => props,
      (newValue) => {
        var _a;
        const copy = { ...newValue };
        for (let k in copy) {
          if (copy[k] === void 0) {
            delete copy[k];
          }
        }
        (_a = editorRef.value) == null ? void 0 : _a.$set(copy);
      },
      { deep: true }
    );
    onMounted(() => {
      const editor2 = new Editor({
        target: el.value,
        props
      });
      editor2.$on("change", (e) => {
        emit("change", e.detail.value);
      });
      editorRef.value = editor2;
    });
    return { el };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1$1 = { ref: "el" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, null, 512);
}
const editor = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const _sfc_main = defineComponent({
  props: ["value", "plugins", "sanitize", "remarkRehype"],
  setup(props, ctx) {
    const markdownBody = ref(null);
    const cbs = ref([]);
    const file = computed(() => {
      return getProcessor(props).processSync(props.value);
    });
    const needUpdate = computed(() => {
      return [file, props.plugins, props.sanitize, props.remarkRehype];
    });
    watch(
      needUpdate,
      () => {
        off();
        nextTick(() => {
          on();
        });
      },
      { deep: true }
    );
    onMounted(() => {
      on();
    });
    onUnmounted(() => {
      off();
    });
    const handleClick = (e) => {
      const $ = e.target;
      if ($.tagName !== "A")
        return;
      const href = $.getAttribute("href");
      if (!href || !href.startsWith("#"))
        return;
      const dest = markdownBody.value.querySelector(
        "#user-content-" + href.slice(1)
      );
      if (dest)
        dest.scrollIntoView();
    };
    const off = () => {
      if (cbs.value.length) {
        cbs.value.forEach((cb) => cb && cb());
      }
    };
    const on = () => {
      if (props.plugins && file) {
        cbs.value = props.plugins.map(
          ({ viewerEffect }) => viewerEffect && viewerEffect({ markdownBody: markdownBody.value, file })
        );
      }
    };
    return { markdownBody, file, handleClick };
  }
});
const _hoisted_1 = ["innerHTML"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    innerHTML: _ctx.file.toString(),
    className: "markdown-body",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    ref: "markdownBody"
  }, null, 8, _hoisted_1);
}
const viewer = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  editor as Editor,
  viewer as Viewer
};
