// Code generated by hertz generator.

package api

import (
	article "blinkable/server/kitex_gen/Article"
	homepage "blinkable/server/kitex_gen/Homepage"
	"blinkable/server/kitex_gen/user"
	api "blinkable/server/service/api/biz/model/api"
	"blinkable/server/service/api/biz/model/base"
	"blinkable/server/service/api/config"
	"blinkable/server/service/api/pkg"
	"context"
	"io"
	"net/http"
	"os"
	"strconv"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

type MinioCen interface {
	UploadFile(bucketName, objectName, filePath string) (url string, err error)
	DownloadFile(bucketName, objectName string) (*os.File, error)
	DeleteFile(bucketName, objectName string) (bool, error)
}

// UserLogin .
// @router /blinkable/user/login [POST]
func UserLogin(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.UserLoginRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api user_login bindAndValidate failed", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(api.UserLoginResponse)
	res, err := config.GlobalUserClient.UserLogin(ctx, &user.UserLoginRequest{
		Username: req.Username,
		Password: req.Password,
	})
	if err != nil {
		hlog.Errorf("user_service rpc call failed: %s", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	resp = &api.UserLoginResponse{
		StatusCode: res.BaseResp.StatusCode,
		StatusMsg:  res.BaseResp.StatusMsg,
		Succed:     res.BaseResp.Succed,
		UserID:     res.UserId,
		Token:      res.Token,
	}

	c.JSON(consts.StatusOK, resp)
}

// UserRegister .
// @router /blinkable/user/register [POST]
func UserRegister(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.UserRegisterRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		hlog.Error("api user_register bindAndValidate failed", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	resp := new(api.UserRegisterResponse)
	res, err := config.GlobalUserClient.UserRegister(ctx, &user.UserRegisterRequest{
		Username: req.Username,
		Password: req.Password,
	})
	if err != nil {
		hlog.Errorf("user_service rpc call failed: %s", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}
	resp = &api.UserRegisterResponse{
		StatusCode: res.BaseResp.StatusCode,
		StatusMsg:  res.BaseResp.StatusMsg,
		Succed:     res.BaseResp.Succed,
		UserID:     res.UserId,
		Token:      res.Token,
	}

	c.JSON(consts.StatusOK, resp)
}

// GetUserInfo .
// @router /blinkable/user/info [GET]
func GetUserInfo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetUserInfoRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	res, err := config.GlobalUserClient.GetUserInfo(ctx, &user.GetUserInfoRequest{
		UserId: req.UserID,
		Token:  req.Token,
	})
	if err != nil {
		hlog.Errorf("get_user_info rpc call failed", err)
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	/*guestbooks := make([]*base.Guestbook, len(res.UserInfo.Guestbooks))

	for i := 0; i < len(guestbooks); i++ {
		guestbooks[i].ID = res.UserInfo.Guestbooks[i].Id
		guestbooks[i].UserID = res.UserInfo.Guestbooks[i].UserId
		guestbooks[i].Context = res.UserInfo.Guestbooks[i].Context
		guestbooks[i].FromUserID = res.UserInfo.Guestbooks[i].FromUserId
		guestbooks[i].CreateTime = res.UserInfo.Guestbooks[i].CreateTime
	}*/

	resp := new(api.GetUserInfoResponse)
	resp.User = new(base.User)
	resp.User.Guestbooks = make([]*base.Guestbook, 0)
	/*make([]*base.Guestbook, len(guestbooks))*/
	resp.User = &base.User{
		ID:            res.UserInfo.Id,
		Name:          res.UserInfo.Name,
		Avatar:        res.UserInfo.Avatar,
		ArticlesNum:   res.UserInfo.ArticlesNum,
		Level:         res.UserInfo.Level,
		Signature:     res.UserInfo.Signature,
		Experience:    res.UserInfo.Experience,
		BackgroundImg: res.UserInfo.BackgroundImg,
		LikeNum:       res.UserInfo.LikeNum,
		GithubURL:     res.UserInfo.GithubUrl,
		Title:         res.UserInfo.Title,
		Guestbooks:    make([]*base.Guestbook, 0),
	}

	resp.StatusCode = res.BaseResp.StatusCode
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.Succed = res.BaseResp.Succed
	c.JSON(consts.StatusOK, resp)
}

// UpdateUserInfo .
// @router /blinkable/user/update [POST]
func UpdateUserInfo(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.UpdateUserInfoRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(api.UpdateUserInfoResponse)
	res, err := config.GlobalUserClient.UpdateUserInfo(ctx, &user.UpdateUserInfoRequest{
		UserId:    req.UserID,
		Username:  req.Username,
		Token:     req.Token,
		Signature: req.Signature,
		Title:     req.Title,
		GithubUrl: req.GithubURL,
	})
	if err != nil {
		hlog.Errorf("update userinfo failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp.Succed = res.BaseResp.Succed
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.StatusCode = res.BaseResp.StatusCode

	c.JSON(consts.StatusOK, resp)
}

// UpdateUserPassword .
// @router /blinkable/user/update/password [POST]
func UpdateUserPassword(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.UpdateUserPasswordRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(api.UpdateUserPasswordResponse)
	res, err := config.GlobalUserClient.UpdateUserPassword(ctx, &user.UpdateUserPasswordRequest{
		UserId:       req.UserID,
		Token:        req.Token,
		Newpassword_: req.NewPasswd,
		Oldpassword:  req.OldPasswd,
	})
	if err != nil {
		hlog.Errorf("update user password failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp.StatusCode = res.BaseResp.StatusCode
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.Succed = res.BaseResp.Succed

	c.JSON(consts.StatusOK, resp)
}

// GetHomePage .
// @router /blinkable/homepage/get [GET]
func GetHomePage(ctx context.Context, c *app.RequestContext) {
	var err error
	resp := new(api.GetHomepageResponse)
	res, err := config.GlobalHomepageClient.GetMainview(ctx, &homepage.GetHomepageRequest{})
	if err != nil {
		hlog.Errorf("gethomepage failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp.Users = make([]*base.User, len(res.Users))

	for i := 0; i < len(res.Users); i++ {
		resp.Users[i] = &base.User{
			ID:            res.Users[i].Id,
			Name:          res.Users[i].Name,
			Avatar:        res.Users[i].Avatar,
			ArticlesNum:   res.Users[i].ArticlesNum,
			Level:         res.Users[i].Level,
			Signature:     res.Users[i].Signature,
			Experience:    res.Users[i].Experience,
			BackgroundImg: res.Users[i].BackgroundImg,
			LikeNum:       res.Users[i].LikeNum,
			GithubURL:     res.Users[i].GithubUrl,
			Title:         res.Users[i].Title,
			Guestbooks:    make([]*base.Guestbook, len(res.Users[i].Guestbooks)),
		}

		for j := 0; j < len(res.Users[i].Guestbooks); j++ {
			resp.Users[i].Guestbooks[j] = &base.Guestbook{
				ID:         res.Users[i].Guestbooks[j].Id,
				UserID:     res.Users[i].Guestbooks[j].UserId,
				Context:    res.Users[i].Guestbooks[j].Context,
				FromUserID: res.Users[i].Guestbooks[j].FromUserId,
				CreateTime: res.Users[i].Guestbooks[j].CreateTime,
			}
		}
	}

	resp.StatusCode = http.StatusOK
	resp.Succed = true
	resp.StatusMsg = "ok"
	c.JSON(consts.StatusOK, resp)
}

// AddGuestbook .
// @router /blinkable/homepage/guestbook [POST]
func AddGuestbook(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.AddGuestbookRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(api.AddGuestbookResponse)
	res, err := config.GlobalHomepageClient.AddGuestbook(ctx, &homepage.AddGuestbookRequest{
		UserId:     req.UserID,
		FromUserId: req.FromUserID,
		Context:    req.Context,
	})
	if err != nil {
		hlog.Errorf("addguestbook failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp.Succed = res.Succed
	resp.StatusMsg = res.StatusMsg
	resp.StatusCode = res.StatusCode

	c.JSON(consts.StatusOK, resp)
}

// LikeAction .
// @router blinkable/homepage/like [POST]
func LikeAction(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.LikeRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(api.LikeResponse)
	res, err := config.GlobalHomepageClient.LikeAction(ctx, &homepage.LikeRequest{
		UserId:     req.UserID,
		FromUserId: req.FromUserID,
	})
	if err != nil {
		hlog.Errorf("like failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp.Succed = res.Succed
	resp.StatusMsg = res.StatusMsg
	resp.StatusCode = res.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// GetArticleSum .
// @router blinkable/article/sum [GET]
func GetArticleSum(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetArticlesumRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	res, err := config.GlobalArticleClient.GetArticleSum(ctx, &article.GetArticleSumRequest{Token: req.Token})
	if err != nil {
		hlog.Errorf("get article sum failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(api.GetArticlesumResponse)
	resp = &api.GetArticlesumResponse{
		StatusCode: res.StatusCode,
		StatusMsg:  res.StatusMsg,
		Succed:     res.Succed,
		Sum:        res.Sum,
	}
	c.JSON(consts.StatusOK, resp)
}

// GetArtcleList .
// @router blinkable/article/list [GET]
func GetArtcleList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetArticlelistRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	res, err := config.GlobalArticleClient.GetArticleList(ctx, &article.GetArticleListRequest{
		Start: req.Start,
		End:   req.End,
	})
	if err != nil {
		hlog.Errorf("get article list failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(api.GetArticlelistResponse)

	resp.Articles = make([]*base.ArticleMsg, len(res.Articles))

	for i := 0; i < len(res.Articles); i++ {
		resp.Articles[i] = &base.ArticleMsg{
			CreateTime: res.Articles[i].CreateTime,
			UpdateTime: res.Articles[i].UpdateTime,
			CreaterID:  res.Articles[i].CreaterId,
			ArticleID:  res.Articles[i].ArticleId,
			Title:      res.Articles[i].Title,
		}
	}

	resp.Succed = res.Succed
	resp.StatusCode = res.StatusCode
	resp.StatusMsg = res.StatusMsg
	c.JSON(consts.StatusOK, resp)
}

// GetArticle .
// @router blinkable/article/get [GET]
func GetArticle(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetArticleRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(api.GetArticleResponse)
	res, err := config.GlobalArticleClient.GetArticle(ctx, &article.GetArticleRequest{ArticleId: req.ArticleID})
	if err != nil {
		hlog.Errorf("get article Msg failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp = &api.GetArticleResponse{
		StatusCode: res.StatusCode,
		StatusMsg:  res.StatusMsg,
		Succed:     res.Succed,
		Content:    res.Content,
		CreaterID:  res.CreaterId,
	}
	resp.Comments = make([]*base.Comment, len(res.Comments))
	for i := 0; i < len(res.Comments); i++ {
		resp.Comments[i] = &base.Comment{
			CommentID:  res.Comments[i].CommentId,
			UserID:     res.Comments[i].UserId,
			Context:    res.Comments[i].Context,
			CreateTime: res.Comments[i].CreateTime,
		}
	}
	c.JSON(consts.StatusOK, resp)
}

// PublishArticle .
// @router blinkable/article/publish [POST]
func PublishArticle(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.PublishArticleRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	res, err := config.GlobalArticleClient.PublishArticle(ctx, &article.PublishArticleRequest{
		UserId:  req.UserID,
		Content: req.Content,
		Title:   req.Title,
	})
	if err != nil {
		hlog.Errorf("publish article  failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(api.PublishArticleResponse)
	resp = &api.PublishArticleResponse{
		StatusCode: res.StatusCode,
		StatusMsg:  res.StatusMsg,
		Succed:     res.Succed,
	}
	c.JSON(consts.StatusOK, resp)
}

// AddComment .
// @router blinkable/article/comment [POST]
func AddComment(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.AddCommentRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(api.AddCommentResponse)
	res, err := config.GlobalArticleClient.AddComment(ctx, &article.AddCommentRequest{
		UserId:    req.UserID,
		ArticleId: req.ArticleID,
		Context:   req.Context,
	})
	if err != nil {
		hlog.Errorf("add article comment failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp = &api.AddCommentResponse{
		StatusCode: res.StatusCode,
		StatusMsg:  res.StatusMsg,
		Succed:     res.Succed,
	}
	c.JSON(consts.StatusOK, resp)
}

// DeleteArticle .
// @router blinkable/article/delet [POST]
func DeleteArticle(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.DeleteArticleRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	res, err := config.GlobalArticleClient.DeleteArticle(ctx, &article.DeleteArticleRequest{
		UserId:    req.UserID,
		ArticleId: req.ArticleID,
	})
	if err != nil {
		hlog.Errorf("delete article failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(api.DeleteArticleResponse)
	resp = &api.DeleteArticleResponse{
		StatusCode: res.StatusCode,
		StatusMsg:  res.StatusMsg,
		Succed:     res.Succed,
	}
	c.JSON(consts.StatusOK, resp)
}

// UploadUserIcon .
// @router /blinkable/user/upload/icon [POST]
func UploadUserIcon(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.UploadUserIconRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	iconfile, err := c.FormFile("file")
	if err != nil {
		hlog.Errorf("filed to get multipart%s", err)
		c.String(consts.StatusInternalServerError, "failed to create temporary file")
		return
	}
	file, err := iconfile.Open()
	if err != nil {
		hlog.Errorf("failde to open multipart%s", err)
		c.String(consts.StatusInternalServerError, "failed to create temporary file")
		return
	}
	iconData, err := io.ReadAll(file)
	if err != nil {
		hlog.Errorf("transform form-data to reader filed:%s", err)
		c.String(consts.StatusInternalServerError, "failed to create temporary file")
		return
	}
	tmpFile, err := os.CreateTemp("", "icon_")
	if err != nil {
		hlog.Errorf("failed to create temporary file:%s", err)
		c.String(consts.StatusInternalServerError, "failed to create temporary file")
		return
	}
	defer tmpFile.Close()
	_, err = tmpFile.Write(iconData)
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to write icon data to temporary file")
		return
	}
	var ext string
	switch http.DetectContentType(iconData) {
	case "image/png":
		ext = "image/png"
	case "image/jpeg":
		ext = "image/jpeg"
	default:
		ext = "image/png"
	}
	if err != nil {
		hlog.Errorf("failed to rename file:%s", err)
		c.String(consts.StatusInternalServerError, "failed to rename temporary file")
		return
	}
	ObjectName := strconv.FormatInt(req.UserID, 10)
	url, err := pkg.NewMinioClient().UploadFile("icons", ObjectName, tmpFile.Name(), ext)
	if err != nil {
		hlog.Errorf("minio upload icon erro %s", err)
		return
	}
	res, err := config.GlobalUserClient.UploadUserIcon(ctx, &user.UploadUserIconRequest{
		UserId:  req.UserID,
		IconUrl: url,
	})
	if err != nil {
		hlog.Errorf("upload icon failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(api.UploadUserIconResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.Succed = res.BaseResp.Succed
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// UploadUserBack .
// @router /blinkable/user/upload/back [POST]
func UploadUserBack(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.UploadUserBackRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	backfile, err := c.FormFile("file")
	if err != nil {
		hlog.Errorf("filed to get multipart%s", err)
		c.String(consts.StatusInternalServerError, "failed to create temporary file")
		return
	}
	file, err := backfile.Open()
	if err != nil {
		hlog.Errorf("failde to open multipart%s", err)
		c.String(consts.StatusInternalServerError, "failed to create temporary file")
		return
	}
	backData, err := io.ReadAll(file)
	if err != nil {
		hlog.Errorf("transform form-data to reader filed:%s", err)
		c.String(consts.StatusInternalServerError, "failed to create temporary file")
		return
	}
	tmpFile, err := os.CreateTemp("", "icon_")
	if err != nil {
		hlog.Errorf("failed to create temporary file:%s", err)
		c.String(consts.StatusInternalServerError, "failed to create temporary file")
		return
	}
	defer tmpFile.Close()
	_, err = tmpFile.Write(backData)
	if err != nil {
		c.String(consts.StatusInternalServerError, "failed to write icon data to temporary file")
		return
	}
	var ext string
	switch http.DetectContentType(backData) {
	case "image/png":
		ext = "image/png"
	case "image/jpeg":
		ext = "image/jpeg"
	default:
		ext = "image/png"
	}
	if err != nil {
		hlog.Errorf("failed to rename file:%s", err)
		c.String(consts.StatusInternalServerError, "failed to rename temporary file")
		return
	}
	ObjectName := strconv.FormatInt(req.UserID, 10)
	url, err := pkg.NewMinioClient().UploadFile("backgournds", ObjectName, tmpFile.Name(), ext)
	if err != nil {
		hlog.Errorf("minio upload icon erro %s", err)
		return
	}
	res, err := config.GlobalUserClient.UploadUserBack(ctx, &user.UploadUserBackRequest{
		UserId:  req.UserID,
		BackUrl: url,
	})
	if err != nil {
		hlog.Errorf("upload background failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp := new(api.UploadUserBackResponse)
	resp.StatusMsg = res.BaseResp.StatusMsg
	resp.Succed = res.BaseResp.Succed
	resp.StatusCode = res.BaseResp.StatusCode
	c.JSON(consts.StatusOK, resp)
}

// BeAdmin .
// @router /blinkable/user/beadmin [POST]
func BeAdmin(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.BeAdminRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	if req.Key != "RookieCoven" {
		c.String(consts.StatusBadRequest, "密钥错误")
		return
	}
	resp := new(api.BeAdminResponse)
	res, err := config.GlobalUserClient.BeAdmin(ctx, &user.BeAdminRequest{UserId: req.UserID})
	if err != nil {
		hlog.Errorf("give admin failed: %s", err)
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	resp.BaseResponse = &base.BaseResponse{
		StatusCode: res.BaseResp.StatusCode,
		StatusMsg:  res.BaseResp.StatusMsg,
		Succed:     res.BaseResp.Succed,
	}
	c.JSON(consts.StatusOK, resp)
}
